  

__invoke

引用：浅谈反序列漏洞

魔法函数

通常来说有一些PHP的魔法函数会导致反序列化漏洞，如：

\_\_construct 当一个类、对象创建时自动调用

\_\_destruct 当对象被销毁时自动调用 (php绝大多数情况下会自动调用销毁对象)

\_\_sleep() 使**用serialize()函数时触发

\_\_wakeup 使用unserialse()**函数时会自动调用 把Name后面的属性+1即可绕过
php的特性，当序列化后对象的参数列表中成员个数和实际个数不符合时会绕过 \_\_weakup(); 因而先构造
```php

$aa = new HaHaHa();
$aa->admin = "admin";
$aa->passwd = "wllm";
$stus = serialize($aa);
print_r($stus);

得到

O:6:"HaHaHa":2:{s:5:"admin";s:5:"admin";s:6:"passwd";s:4:"wllm";}

修改得到

O:6:"HaHaHa":3:{s:5:"admin";s:5:"admin";s:6:"passwd";s:4:"wllm";}

上传即可
```

# \_\_toString 当一个对象被当作一个字符串被调用。

\_\_call() 在对象上下文中调用不可访问的方法时触发（调用 不可访问或者 不存在的方法时）

\_\_callStatic() 在静态上下文中调用不可访问的方法时触发

\_\_get() 用于从不可访问的属性读取数据//调用私有属性时使用

\_\_set() 用于将数据写入不可访问的属性

\_\_isset() 在不可访问的属性上调用isset()或empty()触发

\_\_unset() 在不可访问的属性上使用unset()时触发

\_\_toString() 把类当作字符串使用时触发,返回值需要为字符串

\_\_invoke() 当尝试将对象调用为函数时触发

```php
__invoke():当尝试以调用函数的方式调用对象的时候，就会调用该方法
__construst():具有构造函数的类在创建新对象的时候，回调此方法
__destruct():反序列化的时候，或者对象销毁的时候调用
__wakeup():反序列化的时候调用
__sleep():序列化的时候调用
__toString():把类当成字符串的时候调用，一般在echo处生效
__set():在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用
__get():读取不可访问或者不存在的属性的时候，进行赋值
__call():在对象中调用一个不可访问的方法的时候，会被执行
```

调用unserialize()时会自动调用魔法函数wakeup(),可以通过改变属性数绕过，把Name后面的2改为3或以上即可 ， 然后url识别不了"，改为%22， 因为成员（属性）是private，所以要在类名和成员名前加%00这个url编码是空的意思。因为生产序列化时不会把这个空也输出。 也可以直接用序列化后的url编码。这里要注意，php的urlencode()是会自动把空编码成%00，而Python的parse.quote()不会，编码后一样要把属性2改为3或以上。

# 访问修饰符

|PHP5|Public|Protected|Private|
|---|---|---|---|
|本类|可以访问|可以访问|可以访问|
|子类|可以访问|可以访问|不能访问|
|外部|可以访问|不能访问|不能访问|

php5：url编码绕过

php7：public（属性权限不做验证）