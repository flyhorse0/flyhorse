# 字符逃逸

前言  
php反序列化的字符逃逸算是比较难理解的一个知识点，在最近的好几场比赛中都出现了相关的题，于是下定决心彻底理解透彻这个知识点，于是便有了这篇文章。  
本文涉及知识点实操练习——[PHP反序列化漏洞实验](https://link.zhihu.com/?target=https%3A//www.hetianlab.com/expc.do%3Fec%3DECID172.19.104.182016010714511600001%26pk_campaign%3Dcsdn-wemedia)：通过本次实操，大家将会明白什么是反序列化漏洞，反序列化漏洞的成因以及如何挖掘和预防此类漏洞。  
基础知识理解  
字符逃逸在理解之后就能够明白，这是一种闭合的思想，它类似SQL中的万能密码，理解这种原理之后会变得特别容易。  
在SQL注入中，我们常用'、"来对注入点进行一些闭合或者一些试探，从而进行各种姿势的注入，反序列化时，序列化的值是以;作为字段的分隔，在结尾是以}结束，我们稍微了解一下，

```php
<?php

 class people{

    public $name = 'Tom';

    public $sex = 'boy';

    public $age = '12';

 }

 $a = new people();

 print_r(serialize($a));

//O:6:"people":3:{s:4:"name";s:3:"Tom";s:3:"sex";s:3:"boy";s:3:"age";s:2:"12";}
```  
反序列化的过程就是碰到;}与最前面的{配对后，便停止反序列化。我们可以将上面的序列化的值稍作改变：  
O:6:"people":3:{s:4:"name";s:3:"Tom";s:3:"sex";s:3:"boy";s:3:"age";s:2:"12";}123123  
![](1666438326900-2b0ae75f-272e-475e-abb7-85a25a2d517b.webp.jpg)

可以看到，并没有报错，而且也顺利将这个对象反序列化出来了，恰好说明了我们以上所说的闭合的问题，与此同时，修改一些序列化出来的值可以反序列化出我们所知道的对象中里没有的值，在学习绕过__wakeup就能过知道了，这里可以自己去做一些尝试，去理解。  
接下来就是要说到报错的时候了，当你的字符串长度与所描述的长度不一样时，便会报错，比如上图中s:3:"Tom"变成s:4:"Tom"或s:2:"Tom"便会报错，为的就是解决这种报错，所以在字符逃逸中分为两类：  

1.  字符变多
2.  字符减少

关键字符增多  
在题目中，往往对一些关键字会进行一些过滤，使用的手段通常替换关键字，使得一些关键字增多，简单认识一下，正常序列化查看结果

![](1666438363592-a62d32fb-831d-423f-a5de-ecebb3c84c41.webp.jpg)

这里，我们对序列化后的字符串进行了替换，使得后来的反序列化报错，那我们就需要在Tom这里面的字符串做手脚，在username之后只有一个age，所以在双引号里面可以构造我需要的username之后参数的值，这里修改age的值，我们这里将Tom替换为Tom";s:3:"age";s:2:"35";}然后进行反序列化，这里指的是在对username传参的时候进行修改，也就是我们写链子的时候进行的操作

![](1666438473471-2bf37875-75d3-4bac-9f7f-b9583e11e4c7.webp.jpg)

可以看到构造出来的序列化字符串长度为25，而在上面的反序列化过程中，他会将一个**o**变成两个，**oo**，那么得到的应该就是**s:25:"Toom"我们要做的就是让这个双引号里面的字符串在过滤替换之后真的有描述的这么长，让他不要报错，再配合反序列化的特点，（反序列化的过程就是碰到****;}****与最前面的****{****配对后，便停止反序列化）闭合后忽略后面的age:13**的字符串成功使得**age**被修改为35。

而**age**的修改需要前面的字符串username的值长度与描述的一样，这需要我们精确的计算，这里是将一个**o**变成两个，以下就只写o不写Tom，效果一致，我们需要知道我们除了双引号以内的，所构造的字符串长度为多少，即";s:3:"age";s:2:"35";}的长度22，那就需要22个o，

总的来说就是22个o加上后面的字符串长度22，总长度就为44，在被过滤替换后，光o就有44个，符合描述的字符串长度。下面就说明（**为什么叫做逃逸**）

![](1666438697715-0f1a2cca-ffd7-4990-b8c1-0b9607f2d799.webp.jpg)

这里特意写了"将一大串o进行与前面的"闭合了，如果直接反序列化，在序列化出来的值中就包含了";s:3:"age";s:2:"35";}。

反序列的过程中，所描述的字符串长度（这里为44），而后面双引号包裹的字符串长度（这里为22）不够所描述的长度，那么他将会向后吞噬，他会将后双引号吞噬，直至足够所描述的长度，在一切吞噬结束之后，序列化出来的字符串如果不满足反序列化的字符串的格式，就会报错。我们这里是他吞噬结束后，还满足这个格式，所以不报错。

在这个例子中，我们利用他对序列化后的值，进行增加字符串长度的过滤，让他填充双引号内的字符串达到所描述的44这么长，使得后面的s:3:"age";s:2:"35";不被吞噬，让这部分代码逃逸出吞噬，又让他提前遇到}忽略后面的一些不需要的字符串，结束反序列化。