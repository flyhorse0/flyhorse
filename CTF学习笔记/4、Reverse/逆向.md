 ### Reverse

#### 2020.1）z3 签到题                                                      2021.1) glass

这里使用z3工具编写脚本解42元一次方程组。                                                apk逆向+RC4

#### 2020.2）hyperthreading                                         2021.2）baby_bc

简单加解密算法，难度不大。                                                                     bc文件+z3  [ciscn2021 ctf线上赛baby.bc wp（#超详细，带

                                                                                                                     [  逆向新手走过一个又一个小坑）_漫小牛的博客-CSDN博客](https://blog.csdn.net/weixin_43363675/article/details/116940992)

### 2020.3）oplog

SMC（Self Modifying Code）技术

### PWN

#### 2020.1）easybox                                                           2021.1）lonelywolf

只有一个off by one                                                                                 一个简单的 `2.27`的 `double-free`的`tcache`攻击

#### 2020.2） maj                                                                  2021.2）Channel

UAF                                                                                                                  `aarch64`架构的，一个 `2.31`版本的 `double-free`的攻击。

#### 2020.3） babyjsc                                                           2021.3)

**python27**存在**input**代码执行的漏洞                                                         沙箱read`的`rop`，读取`orw`到`free_hook

#### 2020.4）wow                                                                 2021.4game

缓冲区紧接着的指令指针存在off by one                                          和之前虎符线上的 `vm`很像，不过这道题更简单，没有边界检查，

                                                                                                               又是 `x86`架构。唯一的是通过修改 `size`，实现堆重叠，劫持

                                                                                                             `free_hook`，最后执行 `orw`。

2021pwn:pwny and lonelywolf :[https://x1ng.top/2021/05/16/ciscn-初赛-2021-wp/](https://x1ng.top/2021/05/16/ciscn-%E5%88%9D%E8%B5%9B-2021-wp/)

lonelywolf:[https://www.cnblogs.com/Sentry-Prisoner/p/15335427.html](https://www.cnblogs.com/Sentry-Prisoner/p/15335427.html)

# 逆向

PYC文件简介¶

不说废话,这里说的pyc文件就是 Python 程序编译后得到的字节码文件 (py->pyc).
基本格式¶

pyc文件一般由3个部分组成:

```
最开始4个字节是一个Maigc int, 标识此pyc的版本信息, 不同的版本的 Magic 都在 Python/import.c 内定义
接下来四个字节还是个int,是pyc产生的时间(1970.01.01到产生pyc时候的秒数)
接下来是个序列化了的 PyCodeObject(此结构在 Include/code.h 内定义),序列化方法在 Python/marshal.c 内定义
```

前两个字段的读写很简单,接下来咱们主要看一下 PyCodeObject 的序列化过程, 由于 PyCodeObject 内还有其他很多类型的 PyObject, 所以咱们从一般的 PyObject 的序列化开始看起:
PyObject的序列化¶

PyObject的序列化在 Python/marshal.c 内实现, 一般是先写入一个 byte 来标识此 PyObject 的类型, 每种 PyObject 对应的类型也在 Python/marshal.c 内定义:

//Python/marshal.c:22
#define TYPE_NULL               '0'
#define TYPE_NONE               'N'
#define TYPE_FALSE              'F'
#define TYPE_TRUE               'T'
#define TYPE_STOPITER           'S'
#define TYPE_ELLIPSIS           '.'
#define TYPE_INT                'i'
#define TYPE_INT64              'I'
#define TYPE_FLOAT              'f'
#define TYPE_BINARY_FLOAT       'g'
#define TYPE_COMPLEX            'x'
#define TYPE_BINARY_COMPLEX     'y'
#define TYPE_LONG               'l'
#define TYPE_STRING             's'
#define TYPE_INTERNED           't'
#define TYPE_STRINGREF          'R'
#define TYPE_TUPLE              '('
#define TYPE_LIST               '['
#define TYPE_DICT               '{'
#define TYPE_CODE               'c'
#define TYPE_UNICODE            'u'
#define TYPE_UNKNOWN            '?'
#define TYPE_SET                '<'
#define TYPE_FROZENSET          '>'

之后是 PyObject 的具体数据内容, 变长的对象(str, tuple, list 等)往往还包含了一个 4 bytes 的 len, 比如 PyIntObject 的存储可能是这样的:
‘i’	4 bytes int
‘I’	8 bytes int

而 PyStringObject 的存储是这样的:
‘s’	4 bytes length	length bytes content(char[])

PyTupleObject 和 PyListObject 的存储分别是:
‘(‘	4 bytes length	length 个 PyObject
‘[‘	4 bytes length	length 个 PyObject

各种 PyObject 如何序列化,哪些内容被参与了序列化, 可以参看 Python/marshal.c 内的函数 w_object 函数, 接下来咱们着重看下前面提到的 PyCodeObject 的序列化:
PyCodeObject 的序列化¶

结构体 PyCodeObject 在 Include/code.h 中定义如下:

//Include/code.h
typedef struct {
PyObject_HEAD
int co_argcount;        /_ #arguments, except _args */
int co_nlocals;     /_ #local variables _/
int co_stacksize;       /_ #entries needed for evaluation stack _/
int co_flags;       /* CO_..., see below */
PyObject _co_code;      /_ instruction opcodes */
PyObject _co_consts;    /_ list (constants used) */
PyObject _co_names;     /_ list of strings (names used) */
PyObject _co_varnames;  /_ tuple of strings (local variable names) */
PyObject _co_freevars;  /_ tuple of strings (free variable names) */
PyObject _co_cellvars;      /_ tuple of strings (cell variable names) */
/_ The rest doesn't count for hash/cmp _/
PyObject _co_filename;  /_ string (where it was loaded from) */
PyObject _co_name;      /_ string (name, for reference) */
int co_firstlineno;     /_ first source line number _/
PyObject _co_lnotab;    /_ string (encoding addr<->lineno mapping) See
Objects/lnotab_notes.txt for details. */
void _co_zombieframe;     /_ for optimization only (see frameobject.c) */
PyObject _co_weakreflist;   /_ to support weakrefs to code objects */
} PyCodeObject;

我们再看 Python/marshal.c 里面的 w_object 函数,从中找出写 PyCodeObject 的部分如下:

//...
else if (PyCode_Check(v)) {
PyCodeObject _co = (PyCodeObject _)v;
w_byte(TYPE_CODE, p);
w_long(co->co_argcount, p);
w_long(co->co_nlocals, p);
w_long(co->co_stacksize, p);
w_long(co->co_flags, p);
w_object(co->co_code, p);
w_object(co->co_consts, p);
w_object(co->co_names, p);
w_object(co->co_varnames, p);
w_object(co->co_freevars, p);
w_object(co->co_cellvars, p);
w_object(co->co_filename, p);
w_object(co->co_name, p);
w_long(co->co_firstlineno, p);
w_object(co->co_lnotab, p);
}
//...

根据上面两段代码,我们很容易就能看到 PyCodeObject 里哪些字段需要参数序列化了,我们就挨个解释下需要序列化的字段们:

```
co_argcount : code需要的位置参数个数,不包括变长参数(*args和**kwargs)
co_nlocals : code内所有的局部变量的个数,包括所有参数
co_stacksize : code段运行时所需要的最大栈深度
co_flags : 一些标识位,也在code.h里定义,注释很清楚,比如 CO_NOFREE(64) 表示此 PyCodeObject 内无 freevars 和 cellvars 等
co_code : PyStringObject(‘s’), code对应的字节码(参看 Include/opcode.h 以及此文后续章节)
co_consts : 所有常量组成的tuple
co_names : code所用的到符号表, tuple类型,元素是字符串
co_varnames : code所用到的局部变量名, tuple类型, 元素是 PyStringObject(‘s/t/R’)
co_freevars : code所用到的freevar的变量名,tuple类型, 元素是 PyStringObject(‘s/t/R’)
co_cellvars : code所用到的cellvar的变量名,tuple类型, 元素是 PyStringObject(‘s/t/R’)
co_filename : PyStringObject(‘s’), 此code对应的py文件
co_name : 此code的名称
co_firstlineno : 此code对应的py文件里的第一行的行号
co_lnotab : PyStringObject(‘s’),指令与行号的对应表
```

在 Python 代码中,每个作用域(或者叫block或者名字空间?)对应一个 PyCodeObject 对象, 所以会出现嵌套: 比如 一个 module 类 定义了 N 个 class, 每个 class 内又定义了 M 个方法. 每个 子作用域 对应的 PyCodeObject 会出现在它的 父作用域 对应的 PyCodeObject 的 co_consts 字段里.

接下来用个例子对上面的某些字段做个说明, 比如下面的python代码

#test.py
import struct

def abc(c):
a=1
b=2
return struct.pack("S",a+b+c)

var_a="abc"
var_b={var_a:123,"sec_key":abc}

它编译后对应的 pyc 在 magic 和 time 后就放着一个 PyCodeObject 对象, 这个对象的个字段指如下
test.py对应PyCodeObject中各字段的值 字段	值	注释
co_argcount	0	模块没有参数
co_nlocals	0	模块没有局部变量
co_stacksize	3	栈最大尺寸
co_flags	64	CO_NOFREE
co_code	‘dx00x00d...’	字节码序列
co_consts	(-1, None, another-code-obj...)	所有常量,包括模块里的 function,method
co_names	(‘struct’, ‘abc’, ‘var_a’, ‘var_b’)	此作用域内用到的所有符号
co_varnames	()	局部变量名(模块没有局部变量)
co_freevars	()	freevars
co_cellvars	()	cellvars
co_filename	test.py	源码文件名
co_name	‘’	code名字,模块名都是,class是类名,func是函数名
co_firstlineno	3	此code对应作用域的第一行的行号
co_lnotab	‘x0cx02tx05x06x01’	行号表

这其中的 co_consts 里面的第三个元素是function abc的PyCodeObject, 我们来看下function abc的code的各字段:
function abc 对应PyCodeObject中各字段的值 字段	值	注释
co_argcount	1	1个参数c
co_nlocals	3	1个参数c, 两个局部变量a,b
co_stacksize	4	栈最大尺寸
co_flags	67	CO_OPTIMIZATION | CO_NEWLOCALS | CO_NOFREE
co_code	‘dx01x00}...’	字节码序列
co_consts	(None, 1, 2, ‘S’)	函数里用到的所有常量
co_names	(‘struct’, ‘pack’)	此作用域内用到的所有符号
co_varnames	(‘c’, ‘a’, ‘b’)	局部变量名
co_freevars	()	freevars
co_cellvars	()	cellvars
co_filename	test.py	源码文件名
co_name	‘abc’	code名字,func是函数名
co_firstlineno	5	此code对应作用域的第一行的行号
co_lnotab	‘x00x01x06x01x06x01’	行号表
图解 test.py 与 test.pyc 的结构关系¶

../_images/pyc_format_example_0.png
co_freevars 与 co_cellvars¶

这两个字段是给 Closure 准备的(Python里没有真正的Closure),通俗的说就是函数嵌套的时候用的到,比如:

def outter(o1,o2):
fc1=o1+o2
fc2=o1*o2
def inner(i):
return (fc1+fc2)*i

对于 outter 函数来说,他的局部变量 fc1 和 fc2 被它内部嵌套的函数所引用,则 fc1 和 fc2 变成它的 cellvars 而不是局部变量 varnames

```
对于 inner 函数, fc1 和 fc2 既不是局部变量也不是全局变量,他引用自外层函数, 则 fc1 和 fc2 是 inner 的 freevars
```

PyStringObject 的序列化¶

通过前面的介绍,你可能会发现PyCodeObject里面的用到str(‘s’)类型的地方很多,什么co_consts啊,co_names,co_varnames,co_freevars,co_cellvars等等都是str的tuple,里面的str重复的也比较多,要是一股脑这么写进去可能会占用很大空间,于是w_object里对PyStringObject的序列化又多加了两种类型:

```
‘t’ : interned-string, 暂时可能简单理解为 pyc 里回重复出现的 str, 这个类型就是简单的把 str 的类型 ‘s’ 改成 ‘t’ 了,后面还是跟 length(4bytes) 和 content(char[])
‘R’ : 指向 interned-string 的字符串引用, ‘R’后面跟4个 bytea 的引用序号
```

具体看 Python/marshal.c 内 w_object 的相关实现:

//...
else if (PyString_CheckExact(v)) {
if (p->strings && PyString_CHECK_INTERNED(v)) {
PyObject *o = PyDict_GetItem(p->strings, v);
if (o) {
long w = PyInt_AsLong(o);
w_byte(TYPE_STRINGREF, p);
w_long(w, p);
goto exit;
}
else {
int ok;
o = PyInt_FromSsize_t(PyDict_Size(p->strings));
ok = o &&
PyDict_SetItem(p->strings, v, o) >= 0;
Py_XDECREF(o);
if (!ok) {
p->depth--;
p->error = WFERR_UNMARSHALLABLE;
return;
}
w_byte(TYPE_INTERNED, p);
}
}
else {
w_byte(TYPE_STRING, p);
}
n = PyString_GET_SIZE(v);
if (n > INT_MAX) {
/_ huge strings are not supported _/
p->depth--;
p->error = WFERR_UNMARSHALLABLE;
return;
}
w_long((long)n, p);
w_string(PyString_AS_STRING(v), (int)n, p);
}
//...

行号对照表¶

co_lnotab可以看做是(字节码在co_opcode中的index增量(1 byte),对应的源码的行号增量(1-bytes))顺次串成的的字节数组(字符串).
字段 co_code 与 Python的OPCODE¶

PyCodeObject 的 co_code 字段就是 python opcode 组成的序列, 具体有哪些 opcode可以参看 Include/opcode.h , 这里面有些opcode有参数,有些没有参数, 从opcode.h内的代码段:

#define HAVE_ARGUMENT 90  /_ Opcodes from here have an argument: _/
//...
#define HAS_ARG(op) ((op) >= HAVE_ARGUMENT)

可以看出,大于等与90的opcode是有参数的, 有参数的opcode的参数是两个 unsigned byte, 第一个是操作数, 第二个目前固定为0x00但是不能省略,举例来说,我要把当前code的co_consts里的第二个常量(index是1)载入到栈顶,则对应的opcode序列为: |LOAD_CONST|0x01|0x00| ,也就是 '0x640x010x00'

其他的opcode大都类似,主要是对函数调用栈以及co_consts, co_varnames, co_freevars, co_cellvars的操作, 还有些BUILD_CLASS, BUILD_MAP, BUILD_LIST, BUILD_TUPLE, BUILD_SLICE, MAKE_FUNCTION, MAKE_CLOSURE 等构建对象的特殊指令.

有参数的 opcode 的参数的参数大多时候是个 index, 比如 LOAD_CONST 1 的 1 就是个 index, 表示把当前 PyCodeObject.co_consts[1] 这个常量载入到栈顶, LOAD_FAST 2 则是把 PyCodeObject.co_varnames[2] 这个局部变量载入到栈顶；而 MAKE_FUNCTION 2 则表示栈顶code-obj对应的 function有两个默认参数.

前面 test.pyc 之外的东西, 比如 class/closure 的创建, 也都逃不过这些指令, 具体每个指令的解释和用法可以参看 : [http://docs.python.org/release/2.7/library/dis.html#python-bytecode-instructions](http://docs.python.org/release/2.7/library/dis.html#python-bytecode-instructions)
Page(Article) Information / 页面(文章)信息:¶

```
Author : KDr2
License : | Creative Commons BY-NC-ND 3.0 | CC3.0 : 自由转载-非商用-非衍生-保持署名 |
Hosted on DreamHost
```

**pyc编译网站**：[https://tool.lu/pyc/](https://tool.lu/pyc/)

#### 流浪者-XCTF

文件是exe文件，file命令查看一下。

```
file cm.exe
cm.exe: PE32 executable (GUI) Intel 80386, for MS Windows
```

运行一下文件看看是什么：是一个窗口，让我们输入密码，然后验证对不对。



放进IDA中进行反汇编：先查看字符，根据关键字符串跟进函数。

找到了：请输入pass，这个字符串点进去，ctrl+x快捷键跟进。

```c
int __thiscall sub_401890(CWnd *this)
{
  struct CString *v1; // ST08_4
  CWnd *v2; // eax
  int v3; // eax
  int v5[26]; // [esp+4Ch] [ebp-74h]
  int i; // [esp+B4h] [ebp-Ch]
  char *Str; // [esp+B8h] [ebp-8h]
  CWnd *v8; // [esp+BCh] [ebp-4h]

  v8 = this;
  v1 = (this + 100);
  v2 = CWnd::GetDlgItem(this, 1002);
  CWnd::GetWindowTextA(v2, v1);//获取窗口输入的字符串
  v3 = sub_401A30(v8 + 100);
  Str = CString::GetBuffer((v8 + 100), v3);
  if ( !strlen(Str) )
    return CWnd::MessageBoxA(v8, "请输入pass!", 0, 0);
  for ( i = 0; Str[i]; ++i ) //for循环对字符串中的每个字符进行改变。
  {
    if ( Str[i] > 57 || Str[i] < 48 )
    {
      if ( Str[i] > 122 || Str[i] < 97 )
      {
        if ( Str[i] > 90 || Str[i] < 65 )
          sub_4017B0();
        else
          v5[i] = Str[i] - 29;
      }
      else
      {
        v5[i] = Str[i] - 87;
      }
    }
    else
    {
      v5[i] = Str[i] - 48;
    }
  }
  return sub_4017F0(v5);
}//三个if语句，比较输入字符串中的各个字符。然后对v5数组进行赋值。
```

```c
int __cdecl sub_4017F0(int a1)//这里的a1就是上面函数的v5数组
{
  int result; // eax
  char Str1[28]; // [esp+D8h] [ebp-24h]
  int v3; // [esp+F4h] [ebp-8h]
  int v4; // [esp+F8h] [ebp-4h]

  v4 = 0;
  v3 = 0;
  while ( *(a1 + 4 * v4) < 62 && *(a1 + 4 * v4) >= 0 )//这里用指针来进行操作(相当于数组下标)。因为int型是四个字节，这里4*v4就是数组元素下一个元素的地址
  {
    Str1[v4] = aAbcdefghiabcde[*(a1 + 4 * v4)];
    ++v4;
  }
  Str1[v4] = 0;
  if ( !strcmp(Str1, "KanXueCTF2019JustForhappy") )
    result = sub_401770();
  else
    result = sub_4017B0();
  return result;
}
```

文件对用户输入的字符串进行加密，最后与"KanXueCTF2019JustForhappy"进行比较如果相等就弹出 pass。

我们需要对这两个函数进行逆向操作：

```python
text="KanXueCTF2019JustForhappy"
passwd="abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ"
al=[]
for each in text:
    al.append(passwd.index(each))#对已知比较的字符串来还原，v5数组。

print(al)
v5=al
str1=[]
for i in v5: #逆向三个if语句
    tem1=i+29
    tem2=i+87
    tem3=i+48
    if 65<=tem1<=90:
        str1.append(tem1)
    elif 97<=tem2<=122:
        str1.append(tem2)
    elif 48<=tem3<=57:
        str1.append(tem3)

for each in str1:
    flag=chr(each)
    print(flag,end="")
```

#### babyre--XCTF

文件是六十四位ELF文件，放进IDA中。

这里出现一点问题，这是做逆向以来没有遇到过的



在F5对judge函数进行反汇编时，出现这个错误。



报错的原因是：在主函数中，对指向judge函数的指针地址进行异或操作，在调用时无法找到真正的函数地址。

```python
s=0x600b01
for i in range(182):
  PatchByte((a+i),Byte(a+i)^12)
```

在IDA中运行脚本将函数的地址还原。



这是judge函数，对输入的内容进行异或。

```python
passwd=[102,109,99,100,127,107,55,100,59,86,96,59,110,112]
flag={}
for i in range(14):
    flag[i]=passwd[i]^i
    text=chr(flag[i])
    print(text,end="")
```

#### ctfshow--re2

RC4：[RC4加密算法 - zbility - 博客园 (cnblogs.com)](https://www.cnblogs.com/zibility/p/5404478.html)

#### ctfshow--逆向4

[https://blog.csdn.net/weixin_45582916/article/details/118497453?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~HighlightScore-2.queryctrv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~HighlightScore-2.queryctrv2&utm_relevant_index=5](https://blog.csdn.net/weixin_45582916/article/details/118497453?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-2.queryctrv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-2.queryctrv2&utm_relevant_index=5)

#### **asm逆向**：[(1条消息) 逆向基础—ASM结构代码识别_Leon~博客-CSDN博客](https://blog.csdn.net/sinat_36711025/article/details/106073014)

#### **RSA：参数n的分解网站**[(1条消息) 工具法: 分解 RSA 的 n_ashen的博客-CSDN博客_rsa分解n](https://blog.csdn.net/qq_38063791/article/details/82947840)

#### HGAME_Level-Week2-upx magic 0

考点：crc16

出题人：0wl

分值：150

这题因为放错了附件所以实际上是没有 upx 加壳的，ida 查看字符串可以定位到检验 flag 的地方 题目是静态编译的所以库函数没有符号信息，通过简单的辨别可以知道所对应的库函数 这里的加密是 crc16 ，可以通过爆破的方式得到 flag。





```python
text=[36200,40265,10770,43802,52188,47403,11826,40793,56781,40265,43274,3696,62927,2640,23285,65439,40793,48395,22757,22757,48923,30887,43802,18628,43274,11298,40793,23749,24277,30887,9842,22165]
for k in range(32):
    for i in range(0x2e,0x7e):
        crc=i
        crc<<=8
        for j in range(8):
            if crc&0x8000!=0:
                crc<<=1
                crc=crc^0x1021
            else:
                crc<<=1
        if text[k]==crc&0xffff:
         print(chr(i),end="")
         break
```

#### **HGAME_Week1_Creakme**

**知识点：TEA算法**

```c
#include <stdio.h>
#include <stdint.h>

void decrypt (uint32_t* v, uint32_t* k) {
    uint32_t delta=0x12345678;
    uint32_t v0=v[0], v1=v[1], sum=delta * 32, i;
    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];
    for (i=0; i<32; i++) {
        v1 -= sum ^ ((v0<<4) + k0) ^ (v0 + sum) ^ ((v0>>5) + k1);
        v0 -= sum ^ ((v1<<4) + k2) ^ (v1 + sum) ^ ((v1>>5) + k3);
        sum -= delta;
    }
    v[0]=v0; v[1]=v1;
}

int main()
{
    uint32_t v[]={1222194312u, 51123276u, 1391163586u, 3986482669u, 2921328102u, 3126465133u, 3482485930u, 1709241059u},k[4]={0x44434241,0x48474645,0x4c4b4a49,0x504f4e4d};
    decrypt(v, k);
    decrypt(v + 2, k);
    decrypt(v + 4, k);
    decrypt(v + 8, k);
    printf("%s", v);
    return 0;
}
```

## [ACTF新生赛2020]easyre

![](%E9%80%86%E5%90%91.assets/image-20220215200800038.png#crop=0&crop=0&crop=1&crop=1&id=v2mRV&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

_**data_start**_的内容top为：

![](%E9%80%86%E5%90%91.assets/image-20220215200855164.png#crop=0&crop=0&crop=1&crop=1&id=X45cS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```python
text=[42,70,39,92,34,78,44,92,34,40,73,63,43,64]
table="~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$# !\"0"
for i in text:
    num=table.find(chr(i))+1
    print(chr(num),end="")
```

#### rsa

##### 从PKCS#1格式RSA公钥提取模数(modulus)和指数(exponent)

PKCS#1格式rsa公钥的pem文件内容：

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApuT2wKtxEj1kr7CHj3GT
eeg1JIaSfiM8hzGvc3ntd84MCF0U/SnLOAVZ3C8J+2mfymBy7Zc83sC7+dc0KzuF
jWI47QQHiafh+8YNbljgjXMWLJgiovkQxBrJ7nbfMGIol3QEijKL19Sp+yYKfE4+
Fnu8g89dQUhc7pJGNGaN4nLOZtV/bdPLXBXmUIjOBskdTTwYnIiMvSlXwHuYxXHE
qZMs14t22TUAGyBMglx2bnXIh+9wDr3hz4vcaklqFtlpys5tUKVqbvOLq6LBEduL
yOCIPSt24d2oFnfuD7W4EuhfWBa8Z9dZpPqUBGQ4SBb/vq6Ycmrj7/B6iz32Qq+6
hwIDAQAB
-----END PUBLIC KEY-----
123456789
```

除去`-----BEGIN PUBLIC KEY-----`和`-----END PUBLIC KEY-----`两行内容，中间部分为base64编码的数据。首先通过base64解码获取十六进制数据。复制这部分数据到
[此网站](https://cryptii.com/pipes/base64-to-hex)进行base64解码，得到十六进制数据如下：

```
30 82 01 22 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05 00 03 82 01 0f 00 30 82 01 0a 02 82 01 01 00 a6 e4 f6 c0 ab 71 12 3d 64 af b0 87 8f 71 93 79 e8 35 24 86 92 7e 23 3c 87 31 af 73 79 ed 77 ce 0c 08 5d 14 fd 29 cb 38 05 59 dc 2f 09 fb 69 9f ca 60 72 ed 97 3c de c0 bb f9 d7 34 2b 3b 85 8d 62 38 ed 04 07 89 a7 e1 fb c6 0d 6e 58 e0 8d 73 16 2c 98 22 a2 f9 10 c4 1a c9 ee 76 df 30 62 28 97 74 04 8a 32 8b d7 d4 a9 fb 26 0a 7c 4e 3e 16 7b bc 83 cf 5d 41 48 5c ee 92 46 34 66 8d e2 72 ce 66 d5 7f 6d d3 cb 5c 15 e6 50 88 ce 06 c9 1d 4d 3c 18 9c 88 8c bd 29 57 c0 7b 98 c5 71 c4 a9 93 2c d7 8b 76 d9 35 00 1b 20 4c 82 5c 76 6e 75 c8 87 ef 70 0e bd e1 cf 8b dc 6a 49 6a 16 d9 69 ca ce 6d 50 a5 6a 6e f3 8b ab a2 c1 11 db 8b c8 e0 88 3d 2b 76 e1 dd a8 16 77 ee 0f b5 b8 12 e8 5f 58 16 bc 67 d7 59 a4 fa 94 04 64 38 48 16 ff be ae 98 72 6a e3 ef f0 7a 8b 3d f6 42 af ba 87 02 03 01 00 01
1
```

接下来对这十六进制数据进行解析。
这些十六进制数据使用的事TLV编码模式，即tag,length,value的模式对数据进行描述。

- tag

tag一般占一个byte，表示一段数据的开始。常见的如`0x30（SEQUENCE）`、`0x02（INTEGER）`、`0x03（BIT STRING）`等，详细见下表

| Type | ASN.1 class | Encodeing form | Tag value |
| --- | --- | --- | --- |
| BIT STRING | UNIVERSAL | Primitive | 00000011(0x03) |
| BOOLEAN | UNIVERSAL | Primitive | 00000001(0x01) |
| INTEGER | UNIVERSAL | Primitive | 00000010(0x02) |
| NULL | UNIVERSAL | Primitive | 00000101(0x05) |
| OBJECT | IDENTIFIER | UNIVERSAL | Primitive |
| OCTET STRING | UNIVERSAL | Primitive | 00000100(0x04) |
| BMPString | UNIVERSAL | Primitive | 00011110(0x1E) |
| IA5String | UNIVERSAL | Primitive | 00010110(0x16) |
| PrintableString | UNIVERSAL | Primitive | 00010011(0x13) |
| TeletexString | UNIVERSAL | Primitive | 00010100(0x14) |
| UTF8String | UNIVERSAL | Primitive | 00001100(0x0C) |
| SEQUENCE | UNIVERSAL | Constructed | 00110000(0x30) |
| SEQUENCE OF | UNIVERSAL | Constructed | 00110000(0x30) |
| SET | UNIVERSAL | Constructed | 00110001(0x31) |
| SET OF | UNIVERSA | Constructed | 00110001(0x31) |


> [Encoded Tag Bytes](https://docs.microsoft.com/zh-cn/windows/win32/seccertenroll/about-encoded-tag-bytes?redirectedfrom=MSDN)


- length

length为紧接着tag字节后面的一个字节，表示数据的长度，根据length字节的内容，可以分为两种形式，不同的形式有不同的数值。

1. 短模式

当length字节的最高位为0时为短模式，长度的值为length字节本身数值，即低7位所表示的数据大小。

e.g.
0x09 : （0000 1001） 数据长度为9byte
0x71 ：（0111 0001）数据长度为113byte

1. 长模式

当length字节的最高位为1时为长模式，此时length字节中保存的不是数据的大小。真正表示数据大小的值是紧跟在length字节的后面若干个字节。而length字节低7位表示的则是这若干个字节的长度。

e.g.
0x82 0x01 0x22 0x30 0x0d 0x06 … :
假设0x82为length字节。0x82为`1000 0010`，由于最高位为1，说明在这里使用的是长模式。即低7位指示了紧接在其后的多少个字节标识了数据的长度。在这个例子中，低7位为`000 0010`，即2，因此紧接在`0x82`后面的`0x01 0x22`即为数据的长度。即数据长度为290个字节。

- value

数据一般占若干个字节（也可能为0个字节，根据length决定），其长度有length指定。其中，如果tag为BIT STRING（0x03）时，第一个字节表示数据的最后一个字节有多少个位是没有被使用的（即无效的）。

e.g.
0x00 0x11 0x22 …
这个例子中，第一个字节为0x00，表示数据的最后一个字节没有被使用的位数为0，即所有位均有效。

#### 分析流程

对本文的rsa公钥十六进制数据分析结果如下 ：

```
30 ---> SEQUENCE (tag)
82 01 22 ---> 长模式, 数据长度由 01 22 表示，即290bytes(length)
    30 ---> SEQUENCE (tag)
    0d ---> 短模式，长度为0x0d个字节，即13bytes (length)
        06 ---> OBJECT IDENTIFIER (tag)
        09 ---> 短模式，长度为0x09个字节，即9bytes (length)
            2a 86 48 86 f7 0d 01 01 01 ---> OBJECT IDENTIFIER 的数据内容 (value)
    05 ---> NULL (tag)
    00 ---> 短模式，长度为0x00字节（length）
    03 ---> BIT STRING (tag)
    82 01 0f ---> 长模式，数据长度有 01 0f 表示，即271bytes (length)
        00 ---> 本数据最后一个字节没有无效位，即全部有效。
        30 ---> SEQUENCE (tag)
        82 01 0a ---> 长模式，数据长度有 01 0a 表示，即266bytes (length)
            02 ---> INTEGER 表示一个整数 (tag)
            82 01 01 ---> 长模式，数据长度有 01 01 表示，即257bytes (length)
                 00  a6 e4 f6 ... af ba 87 --->整型数，此处为模数，modulus (value)
            02 ---> INTEGER 表示一个整数 (tag)
            03 ---> 短模式，长度为0x03个字节，即3bytes (length)
                01 00 01 ---> 整型数，此处为指数，exponents (value)

12345678910111213141516171819202122
```

在公钥中，一般直接找到第一个0x02，即第一个整型数tag（INTEGER）即为modulus的TLV，第二个0x02为公钥指数的TLV。如果不幸某些数据中也包含了0x02，就只能逐个逐个地推导了。

**公钥解析(提取e,n)**

在http://tool.chacuo.net/cryptrsakeyparse对公钥进行解析

```python
import gmpy2
import rsa

e = 65537
n = 86934482296048119190666062003494800588905656017203025617216654058378322103517
p = 285960468890451637935629440372639283459
q = 304008741604601924494328155975272418463

phin = (q-1)*(p-1)
d = gmpy2.invert(e, phin)

key = rsa.PrivateKey(n, e, int(d), p, q)

with open("C:\\Users\\shuai\\Desktop\\41c4e672-98c5-43e5-adf4-49d75db307e4\\output\\flag.enc","rb+") as f:
    f = f.read()
    print(rsa.decrypt(f, key))
```

## [SUCTF2019]SignIn

这个题目的本质就是RSA算法。但是需要我们去查询一些我们没见过的函数。

![](%E9%80%86%E5%90%91.assets/image-20220217163839110.png#crop=0&crop=0&crop=1&crop=1&id=wAfxU&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

> GMP(The GNU Multiple Precision Arithmetic Library)又叫GNU多精度算术库，是一个提供了很多操作高精度的大整数，[浮点数](https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9%E6%95%B0&spm=1001.2101.3001.7020)的运算的算术库，几乎没有什么精度方面的限制，功能丰富。


**gmp_lib mpz_init_set_str 方法**

初始化 _rop_ 并像[mpz_set_str](https://machinecognitis.github.io/Math.Gmp.Native/html/6a3819df-abc1-ceb1-a5c7-87a879977b8c.htm)一样设置其值。

```
public static int mpz_init_set_str(
	mpz_t rop,
	char_ptr str,
	int base
)
```

**参数**

-  _人事 登记_
Type： [Math.Gmp.NativeAddLanguageSpecificTextSet（"LST99675DD9_1？cs=.|vb=.|cpp=：：|nu=.|fs=."）;](https://machinecognitis.github.io/Math.Gmp.Native/html/8beda7fb-bbc4-b56f-fd1f-1459377ecb3b.htm) mpz_t目标整数。 
-  _str_
Type： [Math.Gmp.NativeAddLanguageSpecificTextSet（"LST99675DD9_2？cs=.|vb=.|cpp=：：|nu=.|fs=."）;](https://machinecognitis.github.io/Math.Gmp.Native/html/06249483-9daf-95f9-32c7-30195550bbcc.htm) char_ptr源整数。 
-  _基础_
Type： [SystemAddLanguageSpecificTextSet（"LST99675DD9_3？cs=.|vb=.|cpp=：：|nu=.|fs=."）;Int32](http://msdn2.microsoft.com/en-us/library/td2s409d) 基地。 

**返回值**

类型：[Int32](http://msdn2.microsoft.com/en-us/library/td2s409d)
如果字符串是正确的_基_数，则该函数返回 0;如果发生错误，则返回 −1。即使发生错误_，也会初始化 rop_。

**gmp_lib。mpz_powm方法**

将 _rop_ 设置为 （_base_^_exp_） 模 _mod_。

**命名空间：** [Math.Gmp.Native](https://machinecognitis.github.io/Math.Gmp.Native/html/d9c51b9f-0c54-770b-28ea-6eebd8fef368.htm)
**Assembly：** Math.Gmp.Native （in Math.Gmp.Native.dll） 版本： 1.0.0.0 （1.0.0.0）

[https://machinecognitis.github.io/Math.Gmp.Native/html/9de702f4-758b-2a4e-1025-ed5e46cc7db2.htm#](https://machinecognitis.github.io/Math.Gmp.Native/html/9de702f4-758b-2a4e-1025-ed5e46cc7db2.htm#))

```
public static void mpz_powm(
	mpz_t rop,
	mpz_t base,
	mpz_t exp,
	mpz_t mod
)
```

#### 参数

-  _人事 登记_
类型： [数学.Gmp.本地.](https://machinecognitis.github.io/Math.Gmp.Native/html/8beda7fb-bbc4-b56f-fd1f-1459377ecb3b.htm) mpz_t结果整数。 
-  _基础_
类型： [数学.Gmp.本地.](https://machinecognitis.github.io/Math.Gmp.Native/html/8beda7fb-bbc4-b56f-fd1f-1459377ecb3b.htm) mpz_t基本整数。 
-  _exp_
类型： [数学.Gmp.本地.](https://machinecognitis.github.io/Math.Gmp.Native/html/8beda7fb-bbc4-b56f-fd1f-1459377ecb3b.htm) mpz_t指数整数。 
-  _国防部_
类型： [数学.Gmp.本地.](https://machinecognitis.github.io/Math.Gmp.Native/html/8beda7fb-bbc4-b56f-fd1f-1459377ecb3b.htm) mpz_t模整数。 

```python
import gmpy2
from Crypto.Util. number import *
import math
p=  282164587459512124844245113950593348271
q = 366669102002966856876605669837014229419
e = 65537
c =0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35
phi = (p-1)*(q-1)
d = gmpy2.invert(e, phi)
n=103461035900816914121390101299049044413950405173712170434161686539878160984549
m = pow(c,d,n)
print(hex(m))
```

## BUUCTF--Transform

![](%E9%80%86%E5%90%91.assets/image-20220217205909344.png#crop=0&crop=0&crop=1&crop=1&id=XAQKc&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](%E9%80%86%E5%90%91.assets/image-20220217205929193.png#crop=0&crop=0&crop=1&crop=1&id=TAOhR&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

1.先将我们输入的字符串，以dword_40f040数组的值为下表，将输入的值打乱。

2.然后再跟数组byte_40f0e0中的值进行异或。

```python
str=[0x9,0x0A, 0x0F, 0x17, 0x7, 0x18, 0x0C, 0x6, 0x1, 0x10, 0x3,0x11, 0x20,0x1D, 0x0B, 0x1E, 0x1B, 0x16, 0x4, 0x0D, 0x13, 0x14, 0x15, 0x2, 0x19,0x5, 0x1F, 0x8, 0x12, 0x1A, 0x1C, 0x0E,0]
str1=[0x67, 0x79, 0x7B, 0x7F, 0x75, 0x2B, 0x3C, 0x52, 0x53, 0x79, 0x57,0x5E, 0x5D, 0x42, 0x7B, 0x2D, 0x2A, 0x66, 0x42, 0x7E, 0x4C, 0x57,0x79, 0x41, 0x6B, 0x7E, 0x65, 0x3C, 0x5C, 0x45, 0x6F, 0x62, 0x4D]
flag={}
for i in range(33): #先还原顺序
   str1[i]^=str[i]

for i in range(33):#异或逆操作
    flag[str[i]]=str1[i]

for i in range(33):
    print(chr(flag[i]),end="")
```

## [ACTF新生赛2020]usualCrypt

魔改base64表。还将base64编码后的内容进行了大小写转换。

![](%E9%80%86%E5%90%91.assets/image-20220219170552066.png#crop=0&crop=0&crop=1&crop=1&id=F97wK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这个函数是将base64表进行了顺序变换。

![](%E9%80%86%E5%90%91.assets/image-20220219170654838.png#crop=0&crop=0&crop=1&crop=1&id=wAgkK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这里是进行了base64编码。

![](%E9%80%86%E5%90%91.assets/image-20220219170728574.png#crop=0&crop=0&crop=1&crop=1&id=jbjrL&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这里是进行大小写的转换。

反过来，先将byte_40E0E4大小写互换，构造base64变表，再利用变表将byte_40E0E4转换为正常的base64解密就行。

```python
import  base64
Str = list("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
model = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
for i in range(6,15):
    Str[i],Str[i+10] = Str[i+10],Str[i]
Str = ''.join(Str)
enc = "zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9".swapcase()
dec = ""
for i in range(len(enc)):
    dec += model[Str.find(enc[i])]
print (dec)
print (Str)
print (base64.b64decode(dec))
```

## BUUCTF--Youngter-drive

![](%E9%80%86%E5%90%91.assets/image-20220219223445387.png#crop=0&crop=0&crop=1&crop=1&id=WXywc&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

EXE程序有UPX壳，工具解一下壳就行了。

menu()函数，是我重名的为了方便查阅代码。这个函数就是打印一个图案，然后就我们输入字符串。

> HANDLE CreateMutexW(//创建或打开一个已命名或未命名的互斥对象。
>  
> LPSECURITY_ATTRIBUTES lpMutexAttributes,
>  
> BOOL                  bInitialOwner,
>  
> LPCWSTR               lpName );//本题中将hObject所指线程置空


什么是互斥对象呢，这个我也不太懂（哈哈)

> HANDLE CreateThread(
LPSECURITY_ATTRIBUTES lpThreadAttributes,
DWORD dwStackSize,
LPTHREAD_START_ROUTINE lpStartAddress,
LPVOID lpParameter,
DWORD dwCreationFlags,
LPDWORD lpThreadID
);
>  
> 参数的含义如下：
>  
> lpThreadAttrivutes：指向SECURITY_ATTRIBUTES的指针，用于定义新线程的安全属性，一般设置成NULL；
>  
> dwStackSize：分配以字节数表示的线程堆栈的大小，默认值是0；
>  
> lpStartAddress：指向一个线程函数地址。每个线程都有自己的线程函数，线程函数是线程具体的执行代码；
>  
> lpParameter：传递给线程函数的参数；
>  
> dwCreationFlags：表示创建线程的运行状态，其中CREATE_SUSPEND表示挂起当前创建的线程，而0表示立即执行当前创建的进程；
>  
> lpThreadID：返回新创建的线程的ID编号；
>  
> 如果函数调用成功，则返回新线程的句柄，调用WaitForSingleObject函数等待所创建线程的运行结束。


> **CloseHandle函数**
>  
> BOOL CloseHandle(HANDLE hObject);
>  
> 参数
>  
> hObject ：代表一个已打开对象handle。
>  
> 返回值
>  
> TRUE：执行成功； FALSE：执行失败，可以调用GetLastError()获知失败原因。
>  
> 函数说明：关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等。在CreateThread成功之后会返回一个hThread的handle，且内核对象的计数加1，CloseHandle之后，引用计数减1，当变为0时，系统删除内核对象。若在线程执行完之后，没有调用CloseHandle，在进程执行期间，将会造成内核对象的泄露，相当于句柄泄露，但不同于内存泄露，这势必会对系统的效率带来一定程度上的负面影响。但当进程结束退出后，系统会自动清理这些资源。


本题创建了两个线程，分别执行两个函数：StartAddress   sub_41119F

对于第一个线程

![](%E9%80%86%E5%90%91.assets/image-20220219224506009.png#crop=0&crop=0&crop=1&crop=1&id=hW50X&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

sub_41112C()这个函数中存在对我们输入的字符串进行加密的函数，如下图：

![](%E9%80%86%E5%90%91.assets/image-20220219224437545.png#crop=0&crop=0&crop=1&crop=1&id=UkzAh&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这里off_418000[0]的内容为：QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasd

再来看第二个线程，内容：

![](%E9%80%86%E5%90%91.assets/image-20220219224715846.png#crop=0&crop=0&crop=1&crop=1&id=XRC84&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

只对dword_418008进行减一的操作。dword_418008的值为：29

sub_411190()这个函数就用来比较加密后的字符串与 off_418004是否相等，off_418004为TOiZiZtOrYaToUwPnToBsOaOapsyS

```python
ciphertext="TOiZiZtOrYaToUwPnToBsOaOapsyS"
flag=''
table="QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm"
for i in range(len(ciphertext)):
    if i%2==0:
        flag+=ciphertext[i]
        continue
    if ciphertext[i].isupper():
        flag+=chr(table.find(ciphertext[i])+96)
    else:
        flag+=chr(table.find(ciphertext[i])+38)
print(flag)
```

## [HDCTF2019]Maze

迷宫题目，花指令去除。

首先程序加上了**upx**壳，我们先使用工具进行简单脱壳。在将程序放进IDA中进行反汇编。

我们会发现，我们在函数栏中找不到**main**函数。不仅如此，我使用快捷键shift+f12对关键字符串进行跟踪时，发现无法跟踪。

在star函数中我们找到了main函数。f5无法显示伪代码。

![](%E9%80%86%E5%90%91.assets/image-20220223194048872.png#crop=0&crop=0&crop=1&crop=1&id=rvkdj&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

查看一下汇编，jnz汇编指令进行跳转(实际就是跳转下一行)。call 指令后面不是一个地址。这时候考虑花指令。我们需要绕过，花指令。

首先我们先把**jnz**这个指令**nop**掉：选中jnz指令在菜单栏中找到Edit-->Patch program-->Assemble

![](%E9%80%86%E5%90%91.assets/image-20220223194516314.png#crop=0&crop=0&crop=1&crop=1&id=DjoRa&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

还是用Ollydebug来nop掉吧。

![](%E9%80%86%E5%90%91.assets/image-20220223220926259.png#crop=0&crop=0&crop=1&crop=1&id=e1kgr&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

将 jnz short maze_beh.0040102F 和db E8 nop掉。然后保存修改后的文件。

再将新的文件放进IDA进行分析。看题目这是一个迷宫题目。

## [GWCTF 2019]xxor

这题主要是异或加上方程组得运算

![](%E9%80%86%E5%90%91.assets/image-20220224221325313.png#crop=0&crop=0&crop=1&crop=1&id=Xsn1m&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这是程序得主函数，我们将输入得6个数保存在v6数组当中。然后对v6进行操作。可以看出sub_400686,是关键函数，点进去看看。

```c
 v3 = *a1;
  v4 = a1[1];
  v5 = 0;
  for ( i = 0; i <= 0x3F; ++i )
  {
    v5 += 1166789954;
    v3 += (v4 + v5 + 11) ^ ((v4 << 6) + *a2) ^ ((v4 >> 9) + a2[1]) ^ 0x20;
    v4 += (v3 + v5 + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 0x10;
  }
  *a1 = v3;
  result = v4;
  a1[1] = v4;
  return result;
```

还有函数是if语句中的应该也有本题有关系，进去看看。

```c
 if ( a1[2] - a1[3] != 2225223423LL || a1[3] + a1[4] != 4201428739LL || a1[2] - a1[4] != 1121399208LL )
  {
    puts("Wrong!");
    result = 0LL;
  }
  else if ( *a1 != -548868226 || a1[5] != -2064448480 || a1[1] != 550153460 )
  {
    puts("Wrong!");
    result = 0LL;
  }
  else
  {
    puts("good!");
    result = 1LL;
  }
```

先把这三个方程组解了。得到a1数组中的六个值，数目和输入的一样哈。

3746099070,550153460,3774025685,

1548802262,2652626477,2230518816

程序逆着回去。这里用C语言或c++来写脚本。python没有整数溢出，得到的结果是一大长串。

```c
#include <iostream>
#include <cstdio>
using namespace std;
int main(void)
{
    unsigned int enc[6] = {3746099070, 550153460, 3774025685, 1548802262, 2652626477, 2230518816};
    int a2[4] = {2, 2, 3, 4};
    int val = 0x40 * 1166789954;
    for(int i=0; i< 6; i+=2)
    {
        int v5 = val;
        unsigned int v3 = enc[i], v4 = enc[i + 1];
        for(int j=0; j< 0x40; j++)
        {
            v4 -= (v3 + v5 + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 0x10;
            v3 -= (v4 + v5 + 11) ^ ((v4 << 6) + *a2) ^ ((v4 >> 9) + a2[1]) ^ 0x20;
            v5 -= 1166789954;
        }
        enc[i] = v3;
        enc[i + 1] = v4;
    }
    for(int i=0; i < 6; i++)
        printf("\'0x%x\', ", enc[i]);
}
```

#### ctfshow卷王杯--简单的re

这道题目和在buu上的这题[GWCTF 2019]xxor极其相似哈。刚好在buu上做完没几天。

```c
\#include <iostream>
\#include <cstdio>
using namespace std;
int main(void)
{
  unsigned int v14[26];
	v14[0] = 1350288828;
 v14[1] = 731421218;
 v14[2] = 1671728960;
 v14[3] = 2831241988;
 v14[4] = 1951471770;
 v14[5] = 2319350991;
 v14[6] = 1657444641;
 v14[7] = 236674178;
 v14[8] = 3281411241;
 v14[9] = 3592850081;
 v14[10] = 581718275;
 v14[11] = 2597100926;
 v14[12] = 575307203;
 v14[13] = 3582510352;
 v14[14] = 3410176996;
 v14[15] = 3064018193;
 v14[16] = 1278546908;
 v14[17] = 1875831745;
 v14[18] = 2741062944;
 v14[19] = 2277786060;
 v14[20] = 2717472665;
 v14[21] = 1047384394;
 v14[22] = 1864926511;
 v14[23] = 1387033695;
 v14[24] = 2442177625;
 v14[25] = 383659259; 
  int a2[2];
  int val = 0x20 * 1865817980;
  for(int i=0; i<26; i+=2)
  {
    int v5 = val;
    unsigned int v3 = v14[i], v4 = v14[i + 1];
    for(int j=0; j< 0x20; j++)
    {
      v4 -= (v3 + v5 ) ^ ((v3*16) +31) ^ ((v3 >> 5) + 124);
      v3 -= (v4 + v5) ^ ((v4*16) + 111) ^ ((v4 >> 5) +54);
      v5 -= 1865817980;
    }
    v14[i] = v3;
    v14[i + 1] = v4;
  }
  for(int i=0; i <26; i++)
    printf("\'0x%x\', ", v14[i]);
}
```

## [WUSTCTF2020]level3

这属于base64变表问题，这里给出脚本，遇到相似的题目可以解题：

```python
import base64
table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
model = list("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")
s = "d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD=="

for i in range(10):
    model[i], model[19-i] = model[19-i], model[i]

model = ''.join(model)
print (model)

table = str.maketrans(model, table)
print(base64.b64decode(s.translate(table)))
```

这里存一下base64算法实现：[(10条消息) C语言 Base64算法_liuchunjie11的博客-CSDN博客_c语言base64](https://blog.csdn.net/liuchunjie11/article/details/80054299)

## [FlareOn6]Overlong

这个题目由两种解决的方法。这里简单记录一下这两种方法。

![](%E9%80%86%E5%90%91.assets/image-20220301143957467.png#crop=0&crop=0&crop=1&crop=1&id=Sr1jb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

![](%E9%80%86%E5%90%91.assets/image-20220301144009890.png#crop=0&crop=0&crop=1&crop=1&id=WJ1BX&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```c
int __cdecl sub_401000(_BYTE *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-8h]
  char v4; // [esp+4h] [ebp-4h]

  if ( (int)(unsigned __int8)*a2 >> 3 == 30 )
  {
    v4 = a2[3] & 0x3F | ((a2[2] & 0x3F) << 6);
    v3 = 4;
  }
  else if ( (int)(unsigned __int8)*a2 >> 4 == 14 )
  {
    v4 = a2[2] & 0x3F | ((a2[1] & 0x3F) << 6);
    v3 = 3;
  }
  else if ( (int)(unsigned __int8)*a2 >> 5 == 6 )
  {
    v4 = a2[1] & 0x3F | ((*a2 & 0x1F) << 6);
    v3 = 2;
  }
  else
  {
    v4 = *a2;
    v3 = 1;
  }
  *a1 = v4;
  return v3;
}
```

![](%E9%80%86%E5%90%91.assets/image-20220301144107216.png#crop=0&crop=0&crop=1&crop=1&id=QwfFS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

第一中我们直接根据程序的加密函数模拟一遍，输出内容：

```c
#include <iostream>

int __cdecl sub_8A1000(char * a1, char* a2)
{
    int v3; // [esp+0h] [ebp-8h]
    char v4; // [esp+4h] [ebp-4h]

    if ((int)(unsigned __int8)*a2 >> 3 == 30)
    {
        v4 = a2[3] & 0x3F | ((a2[2] & 0x3F) << 6);
        v3 = 4;
    }
    else if ((int)(unsigned __int8)*a2 >> 4 == 14)
    {
        v4 = a2[2] & 0x3F | ((a2[1] & 0x3F) << 6);
        v3 = 3;
    }
    else if ((int)(unsigned __int8)*a2 >> 5 == 6)
    {
        v4 = a2[1] & 0x3F | ((*a2 & 0x1F) << 6);
        v3 = 2;
    }
    else
    {
        v4 = *a2;
        v3 = 1;
    }
    *a1 = v4;
    return v3;
}
unsigned int __cdecl sub_8A1160(char* a1, int a2, unsigned int a3)
{
    unsigned int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < a3; ++i)                    // a3 = 28
    {
        a2 += sub_8A1000(a1, (char*)a2);           // a1=text a2=str
        if (!*a1++)
            break;
    }
    return i;
}
int main()
{
    unsigned char ida_chars[] =
    {
      0xE0, 0x81, 0x89, 0xC0, 0xA0, 0xC1, 0xAE, 0xE0, 0x81, 0xA5,
      0xC1, 0xB6, 0xF0, 0x80, 0x81, 0xA5, 0xE0, 0x81, 0xB2, 0xF0,
      0x80, 0x80, 0xA0, 0xE0, 0x81, 0xA2, 0x72, 0x6F, 0xC1, 0xAB,
      0x65, 0xE0, 0x80, 0xA0, 0xE0, 0x81, 0xB4, 0xE0, 0x81, 0xA8,
      0xC1, 0xA5, 0x20, 0xC1, 0xA5, 0xE0, 0x81, 0xAE, 0x63, 0xC1,
      0xAF, 0xE0, 0x81, 0xA4, 0xF0, 0x80, 0x81, 0xA9, 0x6E, 0xC1,
      0xA7, 0xC0, 0xBA, 0x20, 0x49, 0xF0, 0x80, 0x81, 0x9F, 0xC1,
      0xA1, 0xC1, 0x9F, 0xC1, 0x8D, 0xE0, 0x81, 0x9F, 0xC1, 0xB4,
      0xF0, 0x80, 0x81, 0x9F, 0xF0, 0x80, 0x81, 0xA8, 0xC1, 0x9F,
      0xF0, 0x80, 0x81, 0xA5, 0xE0, 0x81, 0x9F, 0xC1, 0xA5, 0xE0,
      0x81, 0x9F, 0xF0, 0x80, 0x81, 0xAE, 0xC1, 0x9F, 0xF0, 0x80,
      0x81, 0x83, 0xC1, 0x9F, 0xE0, 0x81, 0xAF, 0xE0, 0x81, 0x9F,
      0xC1, 0x84, 0x5F, 0xE0, 0x81, 0xA9, 0xF0, 0x80, 0x81, 0x9F,
      0x6E, 0xE0, 0x81, 0x9F, 0xE0, 0x81, 0xA7, 0xE0, 0x81, 0x80,
      0xF0, 0x80, 0x81, 0xA6, 0xF0, 0x80, 0x81, 0xAC, 0xE0, 0x81,
      0xA1, 0xC1, 0xB2, 0xC1, 0xA5, 0xF0, 0x80, 0x80, 0xAD, 0xF0,
      0x80, 0x81, 0xAF, 0x6E, 0xC0, 0xAE, 0xF0, 0x80, 0x81, 0xA3,
      0x6F, 0xF0, 0x80, 0x81, 0xAD, 0x00
    };
    
        char Text[128]; // [esp+0h] [ebp-84h] BYREF
        unsigned int v6; // [esp+80h] [ebp-4h]

        v6 = sub_8A1160(Text, (long long)&ida_chars, 0x5Cu);//这里要转为long long，不然会报错。
        Text[v6] = 0;
        printf("%s", Text);
        return 0;
   
}
```

第二种：就是修改程序加密的长度。

## [FlareOn3]Challenge1

也是base64变表问题，这个脚本比较通用。

```python
import base64
import string

str1 = "x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q"

string1 = "ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/"
string2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))
```

## [ACTF新生赛2020]Oruga

迷宫题目，建议放进010中找到相对的迷宫矩阵。

![](%E9%80%86%E5%90%91.assets/image-20220302203110220.png#crop=0&crop=0&crop=1&crop=1&id=N1js1&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这样比较方便我们看。

![](%E9%80%86%E5%90%91.assets/image-20220302203157797.png#crop=0&crop=0&crop=1&crop=1&id=mKfRS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

外层while循环，就是到0x21时停止，v2为当前位置，v3从输入的第六个字符开始遍历数组，v4实际是对v2位置的移动。

> W 向上移动
>  
> E 向右移动
>  
> M 向下移动
>  
> J 向左移动


第二处，用了个循环，if条件判断的是位置是否到达边界，越界退出。

## [Zer0pts2020]easy strcmp

![](%E9%80%86%E5%90%91.assets/image-20220308171627010.png#crop=0&crop=0&crop=1&crop=1&id=eKSGe&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这是加密函数，先将字符串8个分为一组。再对每一组，进行减去qword_201060[i]。

```python
enc = "********CENSORED********"
m = [0x410A4335494A0942, 0x0B0EF2F50BE619F0, 0x4F0A3A064A35282B]
 
import binascii
 
flag =b""  #由于是字节操作，需要在前面加上b
for i in range(3):
    p = enc[i*8:(i+1)*8]     #将enc字符串8位一组分开
    print(p)
    a = binascii.b2a_hex(p.encode('ascii')[::-1])   #将分开后的字符串转每一位转换成ascii，然后逆序
    print(a)
    b = binascii.a2b_hex(hex(int(a,16) + m[i])[2:])[::-1]   #（enc[i]的ascii+m[i]）的结果是16进制，[2::]是舍弃开头的0x，然后[::-1]逆序
    print(b)
    print('\n')

    flag += b  #拼凑每组还原后的结果
    
print (flag)
```

## [ACTF新生赛2020]Universe_final_answer

这道题我首先发现了10个数目还是较大的方程组，这显然不可能手写去解。我顺便安装了**z3**，学习了z3最简单的解方程组的使用方法。

```
假设有方程组：

30x+15y=675
12x+5y=265
我们使用z3来解这个方程组：

1.设未知数

In [1]: from z3 import *
In [2]: x = Real('x')
In [3]: y = Real('y')
2.列方程

In [4]: s = Solver()
In [5]: s.add(30*x+15*y==675)
In [6]: s.add(12*x+5*y==265)
3.判断方程解的情况并解方程

In [7]: s.check()
Out[7]: sat
In [8]: result = s.model()
4.得出正解

In [9]: print(result)
[y = 5, x = 20]
```

![](%E9%80%86%E5%90%91.assets/image-20220308194111315.png#crop=0&crop=0&crop=1&crop=1&id=xOECK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

这里注意一下顺序有两处改变

## ctfshow萌新赛签退

这道题目学到一些python的知识，还有base64和凯撒算法的python实现。

```python
import string
c_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '()'
flag = 'BozjB3vlZ3ThBn9bZ2jhOH93ZaH9'#这是加密后的密文

def encode(origin_bytes):#这个函数是base64编码算法
    c_bytes = [ '{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes ]#{:>8}这个意思是将b的二进制不够8位的前面补零凑成8位
    resp = ''
    nums = len(c_bytes) // 3
    remain = len(c_bytes) % 3
    integral_part = c_bytes[0:3 * nums]
    for x in [
        0,
        6,
        12,
        18]:
        continue
        tmp_unit = [][int(tmp_unit[x:x + 6], 2)]#将二级制数据六位分为一组
        resp += ''.join([ c_charset[i] for i in tmp_unit ])
        integral_part = integral_part[3:]
    if remain:
        remain_part = ''.join(c_bytes[3 * nums:]) + (3 - remain) * '0' * 8
        tmp_unit = [ int(remain_part[x:x + 6], 2) for x in [
            0,
            6,
            12,
            18] ][:remain + 1]
        resp += ''.join([ c_charset[i] for i in tmp_unit ]) + (3 - remain) * '.'
    return rend(resp)


def rend(s):
    
    def encodeCh(ch):#凯撒加密的算法实现
        
        f = lambda x: chr(((ord(ch) - x) + 2) % 26 + x)#lambda是python中的匿名函数 x是参数，冒号后边是函数的具体实现
        if ch.islower():
            return f(97)
        if (None,).isupper():
            return f(65)

    return (''.join,)((lambda .0: pass)(s))
```

base64python实现参考：[(13条消息) Base64编码算法（Python实现）_Onlyone_1314的博客-CSDN博客](https://blog.csdn.net/Onlyone_1314/article/details/108938039)

### ctfshow真的是签到题

[CTFSHOW内部赛 re01真的是签到题 - CTFshow WP](https://wp.ctf.show/d/90-ctfshow-re01)

[[原创]脱壳小白之ASPack-加壳脱壳-看雪论坛-安全社区|安全招聘|bbs.pediy.com](https://bbs.pediy.com/thread-258265.htm)

[(2条消息) aspack（工具+手动）脱壳_永川的川的博客-CSDN博客_aspack脱壳机](https://blog.csdn.net/weixin_45574485/article/details/100102533)

程序有两个壳一个是aspack一个是upx。找脱壳机进行自动脱壳。

```c
#include<stdio.h>
#include<stdlib.h>
int main()
{
int text[18]={0x6C,0x2F,0x30,0x31,0x32,0x33,0x0B6,0x0BF,0x0A0,0x0CF,0x7C,0x71,0x6A,0x6C,0x70,0x64,0x75,0x63};
int text1[18];
int num=0;
for(int i=17;i>=0;i--)
{
	text1[num]=text[i];
	num++;
}

for(int i=0;i<18;i++)
{
	int sum=text1[i]^i;
	printf("%c",sum);
}
 
}
```

使用C语言写脚本。

## ctfshow来一个派森

程序是用python编译成exe文件的，使用PyInstxtractor将程序反编译成pyc文件。工具项目地址：[mirrors / extremecoders-re / pyinstxtractor · GitCode](https://gitcode.net/mirrors/extremecoders-re/pyinstxtractor?utm_source=csdn_github_accelerator)

> ### ctfshow--re2_归心
>  
>  
> 拖入IDA查看字符串，发现java.exe/openjdk/jre字样，猜测为java打包成的jar转的exe文件。
>  
> jar转exe大多使用exe4j工具，exe4j只是将java程序，使用自己的方式打包了一下而已，所以运行的时候还是会转成jar来运行，而jar文件必定存储在本地的固定位置。所以反编译的步骤如下：
>  
> 1. 运行exe程序；
> 2. 到C盘搜索readme.jar，找到它及其依赖jar包（用Everything可快速搜索）；
> 3. 使用**jd-gui**反编译readme.jar，查看源码找到flag。

> 你应该见过python代码打包成的exe，猜猜这是什么语言
>  
> 附件：readme.zip


[python反编译 - 在线工具 (tool.lu)](https://tool.lu/pyc/)

用在线工具将pyc文件反编译成python文件下载下来。

```python
#!/usr/bin/env python
# visit https://tool.lu/pyc/ for more information

def b58encode(tmp = None):
    tmp = list(map(ord, tmp))
    temp = tmp[0]
    base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    for i in range(len(tmp) - 1):
        temp = temp * 256 + tmp[i + 1]
    
    tmp = []
    while None:
        temp = temp // 58
        if temp == 0:
            break
        temp = ''
        for i in tmp:
            temp += base58[i]
        
    tmp = []
    for i in range(len(temp)):
        tmp.append(chr(ord(temp[i]) ^ i))
    
    check = [
        'A',
        '5',
        'q',
        'O',
        'g',
        'q',
        'd',
        '\x7f',
        '[',
        '\x7f',
        's',
        '{',
        'G',
        'A',
        'x',
        '`',
        'D',
        '@',
        'K',
        'c',
        '-',
        'c',
        ' ',
        'G',
        '+',
        '+',
        '|',
        'x',
        '}',
        'J',
        'h',
        '\\',
        'l']
    if tmp == check:
        return 1

flag = input('\xe8\xbe\x93\xe5\x85\xa5flag\xef\xbc\x9a')
if b58encode(flag):
    print('you win')
else:
    print('try again')
```

先来看一下base58编码的python算法实现：

```python
def b58encode(tmp:str) -> str:
	tmp = list(map(ord,tmp))
	temp = tmp[0]
	base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
	for i in range(len(tmp)-1):
		temp = temp * 256 + tmp[i+1]
	tmp = []
	while True:
		tmp.insert(0,temp % 58)
		temp = temp // 58
		if temp == 0:
			break
	temp = ""
	for i in tmp:
		temp += base58[i]
	return temp

def b58decode(tmp:str) -> str:
	import binascii
	base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
	temp = []
	for i in tmp:
		temp.append(base58.index(i))
	tmp = temp[0]
	for i in range(len(temp)-1):
		tmp = tmp * 58 + temp[i+1]
	return binascii.unhexlify(hex(tmp)[2:].encode("utf-8")).decode("UTF-8")

print(b58encode("ABDCDEFGA"))
print(b58decode("qBLiPgShKjap"))
```

这里粘一下base58的C语言实现

```c
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <cmath>
using namespace std;
int main()
{
    char plainText[] = "abcdefg";
    int i;
    long long sum = 0;
    int len = strlen(plainText) *138/100 + 1;// len * log(2)256 / log(2)(58) + 1
    char base58Table[59] = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    char *encryption = (char *)malloc(len * sizeof(char));
    int index = 0;

    memset(encryption,0,len * sizeof(char));
    
    while(index < strlen(plainText) ) {
        int each = plainText[index];
        for(i = len-1; ;i--) {
            each += encryption[i] * 256;
            encryption[i] = each % 58;
            each /= 58;
            if(0 == each)
                break;
        }
    
        i = 0;//输出
        while(!encryption[i])
            i++;
        for(;i <= len-1; i++) {
            printf("%d ",encryption[i]);
        }
        cout << endl;
        index++;
    }
    
    i = 0;
    while(!encryption[i])
        i++;
    for(;i <= len-1; i++) {
        cout << base58Table[encryption[i]];
    }
    return 0;

}
```

这道题目就是先进行base58编码，然后再进行一次异或。

## buu--crackMe

这题看着题解调试好长时间（太菜了）

[(3条消息) BUUCTF crackMe_1ens的博客-CSDN博客_buuctf crackme](https://blog.csdn.net/weixin_52369224/article/details/121088046)

[https://chowdera.com/2021/11/20211122035019067k.html#DES_288](https://chowdera.com/2021/11/20211122035019067k.html#DES_288)

## 逆向算法系列

#### 一、RC4加密算法。

对称加密，加解密使用同一个key。下面给出RC4算法的C语言实现。

```
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void RC4_init(unsigned char *s,unsigned char *key,unsigned long Len)
{
	int i=0,j=0;
	char k[256]={0};
	unsigned char tmp=0;
	for(i=0;i<256;i++)
	{
		s[i]=i;
		k[i]=key[i%Len];
	}
	for(i=0;i<256;i++)
	{
		j=(j+s[i]+k[i])%256;
		tmp=s[i];
		s[i]=s[j];
		s[j]=tmp;
	}
	
 } 
void RC4_Crypt(unsigned char *s,unsigned char *data, int Len)
{
	int i=0,j=0,t=0;
	unsigned long k=0;
	unsigned char tmp;
	for(k=0;k<Len;k++)
	{
		i=(i+1)%256;
		j=(j+s[i])%256;
		tmp=s[i];
		s[i]=s[j];
		s[j]=tmp;
		t=(s[i]+s[j])%256;
		data[k]^=s[t];
	}
}
int main()
{
  unsigned	char sbox1[256]={0},sbox2[256]={0};
  unsigned char key[256]="woshinidie";
  unsigned char text[]="dsakjfkajkdfjkalfad";
  int len=strlen((char *)text);
  printf("%d ",len);
  RC4_init(sbox1,key,len);
  for (int i = 0; i<256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！
    {
        sbox2[i] = sbox1[i];
    }
  RC4_Crypt(sbox1,text,len);
  printf("加密后：");
  for(int i=0;i<len;i++)
  {
  	printf("%d ",text[i]);
  } 
  printf("解密后：");
  RC4_Crypt(sbox2,text,len);
	for(int i=0;i<len;i++)
  {
  	printf("%c ",text[i]);
  } 
}
```

```python
'''
import cryptocode
myDecryptedMessage = cryptocode.decrypt("c00EtfL9GPq2EItQrkFyPKIMfVFZy0O4ssXtr/V2Io7NMbNS*Brue6Cex4JuWkWU0lUEK2w==*f8EsezuHu2WBstRDlWZiLg==*CZ/4FNMavWZu3kznPrAyeg==", "BDSEC")
print(myDecryptedMessage)
'''

#BDSEC{i_@M_@_RE_n00AA
# -*- coding: UTF-8 -*-
import base64
ct=[0xD8, 0xE5, 0x85, 0xBE, 0xE7, 0xF8, 0x58, 0x75, 0x95, 0x65,
  0x85, 0xE3, 0xA6, 0x47, 0x59, 0xB9, 0x14, 0x6F, 0x33, 0xB5,
  0xCA, 0x84, 0x0B, 0xE7, 0x92, 0x0E, 0xD2, 0xFD, 0x64, 0x18,
  0x96, 0xD0, 0x0F, 0x5E, 0x44, 0x3E]
for i in range( len(ct)):
	ct[i]=ct[i]^0x23
s = ""
for i in ct:
	s += chr(i)

def rc4_main(key="init_key",message="init_message"):
    s_box = rc4_init_sbox(key)
    crypt = rc4_excrypt(message, s_box)
    return crypt
def rc4_init_sbox(key):
    s_box = list(range(256))
    j= 0
    for i in range(256):
        j = (j + s_box[i] + ord(key[i % len(key)]))% 256
        s_box[i], s_box[j] = s_box[j], s_box[i]
    return s_box
def rc4_excrypt(plain,box):
    plain = base64.b64decode(plain.encode( 'utf-8'))
    plain = bytes.decode(plain)
    res = []
    i = j = 0
    for s in plain:
        i = (i +1)% 256
        j=(j + box[i]) % 256
        box[i],box[j] = box[j],box[i]
        t = (box[i] + box[j])% 256
        k = box[t]
        res.append(chr(ord(s)^ k))
    cipher = "".join(res)
    print(cipher)
    return cipher
s = str(base64.b64encode(s.encode( ' utf-8')),'utf-8 ')
rc4_main("thisiskkk",s)
```

#### 绿城杯 easy_re

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int b[300];
int s[300];
char key[10]="tallmewhy";//(变) 
char data[1000]={
  0xF5, 0x8C, 0x8D, 0xE4, 0x9F, 0xA5, 0x28, 0x65, 0x30, 0xF4, 
  0xEB, 0xD3, 0x24, 0xA9, 0x91, 0x1A, 0x6F, 0xD4, 0x6A, 0xD7, 
  0x0B, 0x8D, 0xE8, 0xB8, 0x83, 0x4A, 0x5A, 0x6E, 0xBE, 0xCB, 
  0xF4, 0x4B, 0x99, 0xD6, 0xE6, 0x54, 0x7A, 0x4F, 0x50, 0x14,
  0xE5, 0xEC
};//(变)
int main(){
	int j,q,n;
	for(int i=0;i<256;i++){
		b[i]=key[i%9];  //8是密钥的长度 （变） 
		s[i]=i;
	}
	for(int i=0;i<256;i++){
		j=(j+s[i]+b[i])%256;
		q=s[i];
		s[i]=s[j];
		s[j]=q^0x37;
	}
	for(int i=0;i<256;i++){
		printf("%d ",s[i]);
	}
	printf("\n"); 
	int i=0,t;
	j=0;
	for(int w=0;w<42;w++){  //32是data的长度 （变） 
	
		i=(i+1)%256;
		j=(j+s[i])%256;
		
		q=s[i];
		s[i]=s[j];
		s[j]=q; //交换 
		
		t=(s[i]+s[j])%256;
		data[i-1]^=s[t];//s[t]是最后的密钥 
	}
	puts(data);
	return 0;
}
```

### 安恒三月赛

#### easyre 考点：RC4

```c
#include<iostream>
using namespace std;
#include<iostream>
int s[256];
char t[256];
int k[50];
void swap(int* a, int* b) {
	uint8_t tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}

void Rc4_Init(uint8_t* key, uint32_t klen) {
	int i, j;
	for (i = 0; i < 256; i++) {
		s[i] = i
		t[i] = key[i % klen];
	}
	j = 0;
	for (i = 0; i < 256; i++) {
		j = (j + s[i] + t[i]) % 256;
		swap(&s[i], &s[j]);
	}
}

void __cdecl sub_401619()
{
	int v3; // [esp+10h] [ebp-10h]
	int v4; // [esp+14h] [ebp-Ch]
	int v5; // [esp+18h] [ebp-8h]
	int i; // [esp+1Ch] [ebp-4h]
	int a2 = 42;
	v4 = 0;
	v5 = 0;
	for (i = 0; a2--; k[v4++] = s[(s[v5] + s[i]) % 256])
	{
		i = (i + 1) % 256;
		v5 = (v5 + s[i]) % 256;
		v3 = s[i] + 66;
		s[i] = s[v5] - 33;
		s[i] ^= 2u;
		s[v5] = 5 * v3;
		s[v5] = s[i] - 10;
		s[v5] += s[i];
		s[i] -= 18;
	}
}
int main() {
	uint8_t v2[42];
	uint8_t ket[7] = {49,50,51,52,53,54};
	Rc4_Init(ket, 6);
	sub_401619();
	v2[0] = -61;
	v2[1] = -128;
	v2[2] = -43;
	v2[3] = -14;
	v2[4] = -101;
	v2[5] = 48;
	v2[6] = 11;
	v2[7] = -76;
	v2[8] = 85;
	v2[9] = -34;
	v2[10] = 34;
	v2[11] = -125;
	v2[12] = 47;
	v2[13] = -105;
	v2[14] = -72;
	v2[15] = 32;
	v2[16] = 29;
	v2[17] = 116;
	v2[18] = -47;
	v2[19] = 1;
	v2[20] = 115;
	v2[21] = 26;
	v2[22] = -78;
	v2[23] = -56;
	v2[24] = -59;
	v2[25] = 116;
	v2[26] = -64;
	v2[27] = 91;
	v2[28] = -9;
	v2[29] = 15;
	v2[30] = -45;
	v2[31] = 1;
	v2[32] = 85;
	v2[33] = -78;
	v2[34] = -92;
	v2[35] = -82;
	v2[36] = 123;
	v2[37] = -84;
	v2[38] = 92;
	v2[39] = 86;
	v2[40] = -68;
	v2[41] = 35;
	for (int i = 0; i < 42; i++)
		v2[i] = ((v2[i] - 71) ^ (k[i] & 0xff));
	return 0;
}
#DASCTF{Welc0me-t0-j01n-SU-l0ve-suyug1eg1e}
```

#### TEA加密算法

```c
#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>

void encrypt(uint32_t *v,uint32_t *k)//加密函数 
{
	uint32_t v0=v[0];uint32_t v1=v[1],sum=0,i;
	uint32_t delta=0x9e3779b9;
	uint32_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];
	for(i=0;i<32;i++)
	{
		sum+=delta;
		v0+=((v1<<4)+k0)^(v1+sum)^((v1>>5)+k1);
		v1+=((v0<<4)+k2)^(v0+sum)^((v0>>5)+k3);
	}
	v[0]=v0;
	v[1]=v1;
}

void decrypt(uint32_t *v,uint32_t *k)
{
	uint32_t v0=v[0],v1=v[1],sum=0x9e3779b*32,i;
	uint32_t delta=0x9e3779b9;
	uint32_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];
	for(i=0;i<32;i++)
	{
		v1-=((v0<<4)+k2)^(v0+sum)^((v0<<5)+k3);
		v0-=((v1<<4)+k0)^(v1+sum)^((v1<<5)+k1);
		sum-=delta; 
	}
	v[0]=v0;
	v[1]=v1;
 } 
 int main()
 {
 	uint32_t v[2]={1,2},k[4]={2,2,3,4};
 	printf("加密前数据：");
 	encrypt(v,k);
 	printf("加密后数据：");
 	decrypt(v,k);
 	 printf("解密后的数据：%u %u\n",v[0],v[1]); 
 }
```

#### XTEA加密算法

```c
加密前原始数据：1 2  
加密后的数据：1347371722 925494771  
解密后的数据：1 2  
  
Process returned 0 (0x0)   execution time : 0.020 s  
Press any key to continue.  

XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等，设计者是Roger Needham, David Wheeler
加密过程：



算法实现：

示例代码：

[cpp] view plain copy
#include <stdio.h>  
#include <stdint.h>  
  
/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */  
  
void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {  
    unsigned int i;  
    uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;  
    for (i=0; i < num_rounds; i++) {  
        v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  
        sum += delta;  
        v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) & 3]);  
    }  
    v[0]=v0; v[1]=v1;  
}  
  
void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {  
    unsigned int i;  
    uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;  
    for (i=0; i < num_rounds; i++) {  
        v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) & 3]);  
        sum -= delta;  
        v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  
    }  
    v[0]=v0; v[1]=v1;  
}  
  
int main()  
{  
    uint32_t v[2]={1,2};  
    uint32_t const k[4]={2,2,3,4};  
    unsigned int r=32;//num_rounds建议取值为32  
    // v为要加密的数据是两个32位无符号整数  
    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位  
    printf("加密前原始数据：%u %u\n",v[0],v[1]);  
    encipher(r, v, k);  
    printf("加密后的数据：%u %u\n",v[0],v[1]);  
    decipher(r, v, k);  
    printf("解密后的数据：%u %u\n",v[0],v[1]);  
    return 0;  
}
```

#### XXTEA

```c
#include <stdio.h>
#include <stdint.h>
#define DELTA 0x61C88647
#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))
 
void btea(int  *v, int n, int  const key[4])
{
    int  y, z, sum;
    unsigned p, rounds, e;
    if (n > 1)            /* Coding Part */
    {
        rounds = 6 + 52/n;
        sum = 0;
        z = v[n-1];
        do
        {
            sum -= DELTA;
            e = (sum >> 2) & 3;
            for (p=0; p<n-1; p++)
            {
                y = v[p+1];
                z = v[p] += MX;
            }
            y = v[0];
            z = v[n-1] += MX;
        }
        while (--rounds);
    }
    else if (n < -1)      /* Decoding Part */
    {
        n = -n;
        rounds = 6 + 52/n;
        sum = -rounds*DELTA;
        y = v[0];
        do
        {
            e = (sum >> 2) & 3;
            for (p=n-1; p>0; p--)
            {
                z = v[p-1];
                y = v[p] -= MX;
            }
            z = v[n-1];
            y = v[0] -= MX;
            sum += DELTA;
        }
        while (--rounds);
    }
}
 
 
int main()
{
    int  v5[18] ; //1332124633 889991924{73 ,83 ,67, 67, 123 ,49 ,50, 51, 52 ,53 ,54 ,55, 56, 57 ,48 ,49, 50 ,125};
    int  const k[4] = {73,83,67,67};
    
  v5[0] = -1645474427;
  v5[1] = 1097753491;
  v5[2] = 1470977420;
  v5[3] = -1169585890;
  v5[4] = -1059640595;
  v5[5] = -1480584396;
  v5[6] = -617580414;
  v5[7] = 339254878;
  v5[8] = 1120023008;
  v5[9] = -1264001152;
  v5[10] = 384195221;
  v5[11] = -2105812542;
  v5[12] = 129781519;
  v5[13] = 430940851;
  v5[14] = 1940659838;
  v5[15] = -1822236753;
  v5[16] = 16450049;
  v5[17] = 1900720125;
  
    int n= 18; //n的绝对值表示v的长度，取正表示加密，取负表示解密
    // v为要加密的数据是两个32位无符号整数
    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位
  
   
   	 btea(v5, -n, k);
    for(int i=0;i<18;i++)
    {
    	printf("%c",v5[i]);
	}
   
    return 0;
}
```

**正确的说法：**

**①：1字节（byte） = 8位（bit）**

**②：在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit）**

    **在32位的系统中（比如win32） 1字（word）= 4字节（byte）=32（bit）**

    **在64位的系统中（比如win64）1字（word）= 8字节（byte）=64（bit）**

#### RSA专题

```
r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473
M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558
n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287
e = 3
c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282
P.<x> = PolynomialRing(Zmod(n))
f = (M+x*r)^e - c
k = f.monic().small_roots(X=2^100,beta=1,espilon=0.03)[0]
m = M+k*r
print(bytes.fromhex(hex(m)[2:]))
```

```
1. rsa
2. coopersmith
```

1. 分析源码可以得到rsa 加密的密文c,及其对应的公钥(n,e)和一个512位的素数r，以及M = m%r
2. 加密前的明文是在末尾填充了32位随机字符串的，由于m = M+k*r 首先尝试爆破k，但是我们会发现并不能爆破出来，这时候考虑 k的大小 由于 m的位数约为 591 位，而 r的位数为512位，则k的位数约为 79位。显然k相对来说比较小（但是爆破是不可行的）
3. 我们考虑使用coopersmith 的方法寻找小根k。可以构造如下的多项式：f = (M+x*r)^e -c 在 Zmod(n)的多项式环上有小根x = k,由于k < 2^79 < n^(1/e) 所以我们可以迅速的找到k，恢复m

### SPACeHeroesctf

```python
import sys#题目程序

def main():
  if len(sys.argv) != 2:
    print("Invalid args")
    return

  password = sys.argv[1]
  builder = 0
  
  for c in password:
    builder += ord(c)
  
  if builder == 713 and len(password) == 8 and (ord(password[2]) == ord(password[5])):
    if (ord(password[3]) == ord(password[4])) and ((ord(password[6])) == ord(password[7])):
        print("correct")
    else:
        print("incorrect")
  else:
    print("incorrect")

if __name__ == "__main__":
  main()
```

根据提示爆破

```python
text='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
for c1 in text:
    for c2 in text:
        for c3 in text:
            for c4 in text:
                for c5 in text:
                    flag=f"{c1}{c2}{c3}{c4}{c4}{c3}{c5}{c5}"
                    if ord(c1)+ord(c2)+ord(c3)+ord(c4)+ord(c4)+ord(c3)+ord(c5)+ord(c5)==713:
                         print(flag)
```

最后就是脑洞了。

-   
#### B01lersCTF

一道java逆向 ，不是很难，卡在一个点上了。

这里我粘贴出源码：

```java
import java.util.Random;
import java.util.Scanner;

public class play {
    public play() {
    }

    public static void main(String[] var0) {
        Scanner var1 = new Scanner(System.in);
        System.out.println("What is the flag?");
        String var2 = var1.nextLine();
        if (var2.length() != 22) {
            System.out.println("Not the flag :(");
        } else {
            char[] var3 = new char[var2.length()];

            int var4;
            for(var4 = 0; var4 < var2.length(); ++var4) {
                var3[var4] = var2.charAt(var4);
            }

            for(var4 = 0; var4 < var2.length() / 2; ++var4) {
                char var5 = var3[var2.length() - var4 - 1];
                var3[var2.length() - var4 - 1] = var3[var4];
                var3[var4] = var5;
            }

            int[] var10 = new int[]{19, 17, 15, 6, 9, 4, 18, 8, 16, 13, 21, 11, 7, 0, 12, 3, 5, 2, 20, 14, 10, 1};
            int[] var11 = new int[var3.length];

            for(int var6 = var10.length - 1; var6 >= 0; --var6) {
                var11[var6] = var3[var10[var6]];
            }

            Random var12 = new Random();
            var12.setSeed(431289L);
            int[] var7 = new int[var2.length()];

            for(int var8 = 0; var8 < var2.length(); ++var8) {
                var7[var8] = var11[var8] ^ var12.nextInt(var8 + 1);
            }

            String var13 = "";

            for(int var9 = 0; var9 < var7.length; ++var9) {
                var13 = var13 + var7[var9] + ".";
            }

            System.out.println("\nYOUR FLAG: " + var13);
            if (var13.equals("116.122.54.50.93.66.98.117.75.51.97.78.104.119.90.53.94.36.105.84.40.69.")) {
                System.out.println("Congrats! You got the flag!");
            } else {
                System.out.println("Not the flag :(");
            }

        }
    }
}
```

我这里主要是卡在了排序上了，这个地方想了好久（真菜）

```java
import java.util.Random;

public class play_1 {
    public static void main(String[] args) {
        Random var12 = new Random();
        var12.setSeed(431289L);
        int[] var7 = new int[22];
        int[] randnum = new int[]{0,1,2,1,2,5,4,1,1,7,3,7,0,10,5,5,1,16,10,2,12,17};
        /*for(int var8 = 0; var8 < 22; ++var8){
            var7[var8] =var12.nextInt(var8 + 1);
        }

        for (int i = 0; i < 22; i++) {
            System.out.print(var7[i]+",");
        }*/

        int[] ctext = new int[]{116,122,54,50,93,66,98,117,75,51,97,78,104,119,90,53,94,36,105,84,40,69};
        int[] flag = new int[23];
        for (int i = 0; i < ctext.length; i++) {
            flag[i] = randnum[i]^ctext[i];
        }
        int[] str1 = new int[22];
        int[] index1 = new int[]{19, 17, 15, 6, 9, 4, 18, 8, 16, 13, 21, 11, 7, 0, 12, 3, 5, 2, 20, 14, 10, 1};     //主要卡在了，根据index1数组中的值为下表，进行还原。
        int j =21;
        for (int i = 0; i <22; i++) {

            str1[index1[i]] = flag[i]; //关键代码
            j--;
        } 
        for (int i = 21; i >=0; i--) {
            System.out.print((char)str1[i]);
        }
    }


}
```

## 2022NahamConCTF  **Unimod**

这是一道python的逆向简单题，当时迷在不知道如何对**求余**进行逆向操作，看完题解恍然大悟（太菜了呜呜）。

这里记录一下这个题的简单过程，以防下次碰见相同的题目。

```python
import random

flag = open('flag.txt', 'r').read()
ct = ''
k = random.randrange(0,0xFFFD)
for c in flag:
    ct += chr((ord(c) + k) % 0xFFFD)

open('out', 'w').write(ct)
```

这个是题目的源代码，非常简单。还有out文件，内容是：

```
饇饍饂饈饜餕饆餗餙饅餒餗饂餗餒饃饄餓饆饂餘餓饅餖饇餚餘餒餔餕餕饆餙餕饇餒餒饞飫
```

```python
import string

flag = open('D:\\CTF-Comp\\Nahamcon CTF\\danmo\\out.txt','r',encoding='UTF-8').read()
ptr = ''
ptr = flag[0]

for i in range(0,0xfffd):
    if ptr == chr((ord('f')+i)%0xfffd):
        k = i #39137
for cch in flag:
    for ch in string.printable:
        if cch == chr((ord(ch)+k)%0xfffd):
            print(ch,end="")
```

我们先根据**flag**这个前缀找到题目中的k ，让后通过可见字符进行简单爆破。

### ISCC

#### mobile 1

AES在线解密：[SSL在线工具-AES在线加解密-AES encryption-SSLeye官网](https://www.ssleye.com/ssltool/aes_cipher.html)

```java
public static void main(String[] var0) {
    String encode1 = "=IkMBb+=gF2/Try5PCUruw1j"; 
    char[] cArr = new char[encode1.length()];    
    boolean z = false;
    int i = 0;
    for (int i2 = 5; i2 >= 0; i2--) {
        if (!z) {
            for (int i3 = 3; i3 >= 0; i3--) {
                cArr[(i3 * 6) + i2] = encode1.charAt(i);
                i++;
            }
            z = true;
        } else {
            for (int i4 = 0; i4 <= 3; i4++) {
                cArr[(i4 * 6) + i2] = encode1.charAt(i);
                i++;
            }
            z = false;
        }
    }
   
}
```

#### 擂台赛 mobile1

解a脚本（密文）

```java
//程序1
public static String a() {
    String str = "";
    for (String str2 : "5564733088808870666640774309056659095510999999408882085546730888406099099208888".split("0")) {
        int i = 0;
        for (int i2 = 0; i2 < str2.length(); i2++) {
            i += str2.charAt(i2) - '0';
        }
        str = str + "AjmBCL7DHxIMl4P5Wa=uzvt0ZTfpnoRSJNO9/QYqrsb2U1cdeEFGVXy3ghikKw68".charAt(i - 1);
    }
    return str;
```

运行程序1，得到a 的密文。b 的密文是AES解密得到的。

下面两个程序的思路，在一个长度64的字符串中寻找 a,b的密文中的各个字符得到在长度为64字符串的下标，对（5*index+8）%64逆向。

```java
public static void main(String[] args) {  //J0tpzHRuhTQpLauS
 String str = "otG28PYN8CtG" ;//"J0tpzHRuhTQpLauS"
 a(str);
    //System.out.println(str1);
}
//SVNDQ3tkaXNwbGFj
public static void a(String str) {
    String str2 = "";
    int[] indx = {32,43,53,31,27,35,50,47,27,17,43,53};//{40,45,19,8,34,14,30,35,0,56,54,8,1,5,35,43};
    String str1 = "cdYqrsMneEFwxg78=GfKlLHRSTabBCDtZ012UhiQok6VWmXpjIJNO9/PyzA345uv";
    for (int i = 0; i < str.length(); i++) {
        //str2 = str1.indexOf(str.charAt(i)) != -1 ? str2 + str1.charAt(((5 * str1.indexOf(str.charAt(i))) +  8) % 64) : str2 + str.charAt(i);
        System.out.print(str1.charAt(indx[i])+"");
    }
    //return str2;
```

```python
text = [40,31,17,35,15,55,2,51,15,29,31,17]#[16,41,39,48,50,14,30,55,8,32,22,48,13,33,55,31]
for  c in text:
 for i in range(64):
    if (5*i+8)%64 == c:
        print(i,end=",")#  SVNDQ3tkaXNwbGFjZV9hbHRlcm5hdGl2    ISCC{displace_alternativ
```

SVNDQ3tkaXNwbGFjZV9hbHRlcm5hdGl2ZV9tb2JpbGV9

#### Mobile2

考点：分析lib文件下的so文件，得到转轮机加密的思路。

但是分析apk文件得到 密文：13052010520523012305051302305105120120

但是转轮机加密的密文一般是大写字母，所以还有一个加密。

```java
 a.a(stringFromJNI(str.substring(5, str.length() - 1))).equals("13052010520523012305051302305105120120");
```

这个地方调用了a类的a方法。a方法的思路如下，进行爆破。

```java
public class a {
    public static void main(String[] args) {
        String strings = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String[] strings1 = {"130", "520", "10", "520", "5230", "1230", "50","5130","230", "510", "5120", "120"};
        for (int i = 0; i < strings1.length; i++) {
            for (int j = 0; j < strings.length(); j++) {
                char c = strings.charAt(j);
                String str = a(c);
                if (str.equals(strings1[i]))
                {
                    System.out.print(c);
                }
            }
        }
        }
    public static String a(char charAt) {

        String str2 = "";

        str2 = str2 + sum(0, charAt - 64, 0) + "0";

        return str2;
    }
    public static int sum(int i, int i2, int i3) { // 130 520 10 520 5230 1230 50 5130 230 510 5120 120");
        for (int i4 = 0; i4 < 6; i4++) {
            double d = i2;
            double d2 = i;
            double d3 = i4;
            if (d <= Math.pow(2.0d, d3) + d2) {
                if (d != Math.pow(2.0d, d3) + d2) {
                    double d4 = i4 - 1;
                    return sum((int) (d2 + Math.pow(2.0d, d4)), i2, i3 + 1) + ((int) (d4 * Math.pow(10.0d, i3)));
                } else if (i4 == 0) {
                    return (int) (Math.pow(10.0d, i3) * 5.0d);
                } else {
                    return (int) (d3 * Math.pow(10.0d, i3));
                }
            }
        }
        return -1;
    }
}
```

#### REVERSE1

考点：简单算法逆向

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>


int main()
{
	int v9[20];
v9[0] = 149;
  v9[1] = 169;
  v9[2] = 137;
  v9[3] = 134;
  v9[4] = 212;
  v9[5] = 188;
  v9[6] = 177;
  v9[7] = 184;
  v9[8] = 177;
  v9[9] = 197;
  v9[10] = 192;
  v9[11] = 179;
  v9[12] = 153;
  v9[13] = 125;
  v9[14] = 197;
  v9[15] = 130;
  v9[16] = 160;
  v9[17] = 187;
  v9[18] = 109;
  v9[19] = 184;

char str[21] = "LWHFUENGDJGEFHYDHIGJ"; // 0000 0000 0100 0111


int flag[20] ;

for(int i =0; i<20 ;i++)
{   


    
	
	flag[i] = v9[i] - str[i];
	flag[i] = flag[i]^i;
	
}
   
for(int i =0; i<20; i++)
{
	printf("%c",flag[i]);
	}	
	
}
```

#### REVERSE2

考点：XXTEA加密算法。

```c
#include <stdio.h>
#include <stdint.h>
#define DELTA 0x61C88647
#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))
 
void btea(int  *v, int n, int  const key[4])
{
    int  y, z, sum;
    unsigned p, rounds, e;
    if (n > 1)            /* Coding Part */
    {
        rounds = 6 + 52/n;
        sum = 0;
        z = v[n-1];
        do
        {
            sum -= DELTA;
            e = (sum >> 2) & 3;
            for (p=0; p<n-1; p++)
            {
                y = v[p+1];
                z = v[p] += MX;
            }
            y = v[0];
            z = v[n-1] += MX;
        }
        while (--rounds);
    }
    else if (n < -1)      /* Decoding Part */
    {
        n = -n;
        rounds = 6 + 52/n;
        sum = -rounds*DELTA;
        y = v[0];
        do
        {
            e = (sum >> 2) & 3;
            for (p=n-1; p>0; p--)
            {
                z = v[p-1];
                y = v[p] -= MX;
            }
            z = v[n-1];
            y = v[0] -= MX;
            sum += DELTA;
        }
        while (--rounds);
    }
}
 
 
int main()
{
    int  v5[18] ; //1332124633 889991924{73 ,83 ,67, 67, 123 ,49 ,50, 51, 52 ,53 ,54 ,55, 56, 57 ,48 ,49, 50 ,125};
    int  const k[4] = {73,83,67,67};
    
  v5[0] = -1645474427;
  v5[1] = 1097753491;
  v5[2] = 1470977420;
  v5[3] = -1169585890;
  v5[4] = -1059640595;
  v5[5] = -1480584396;
  v5[6] = -617580414;
  v5[7] = 339254878;
  v5[8] = 1120023008;
  v5[9] = -1264001152;
  v5[10] = 384195221;
  v5[11] = -2105812542;
  v5[12] = 129781519;
  v5[13] = 430940851;
  v5[14] = 1940659838;
  v5[15] = -1822236753;
  v5[16] = 16450049;
  v5[17] = 1900720125;
  
    int n= 18; //n的绝对值表示v的长度，取正表示加密，取负表示解密
    // v为要加密的数据是两个32位无符号整数
    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位
  
   
   	 btea(v5, -n, k);
    for(int i=0;i<18;i++)
    {
    	printf("%c",v5[i]);
	}
   
    return 0;
}
```

#### RESERVER3

考点：z3求解器，解方程。

#### 5月10日新题

#### reverse-1

base58直接解码

#### reverse-2

![](%E9%80%86%E5%90%91.assets/image-20220510162128210.png#crop=0&crop=0&crop=1&crop=1&id=jAeco&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```
.W1BqthGbebprtiozWXBms.1tRoFhKtO81AOzUo2lFoFpptGl0VYvPpYXAoF0.
```

这是密文。这个题有好几个加密。从下网上开始解密。

**sub_4116E0(Str1, 2);**这是凯撒加密直接凯撒解密，偏移为2；

**sub_411023(v9, v8, '.', 0);**
**sub_411023(v8, Str1, '.', 22);**

这个两个函数的意思是分别在原来字符串的基础上，在下标为0和22的位置上添上  **.**

**sub_411389(v10, len_1, v9, 1);**

base64加密，但是把base64的表换了，换成了：ABCDEfghijklmnopqrsTUVWXYZabcdeFGHIJKLMNOPQRStuvwxyz0123456789-_

而且把顺序也进行了变换

```c
 for ( i = 5; i < 19; ++i )
  {
    v12 = Destination[i];
    Destination[i] = Source[i + 26];
    Destination[i + 26] = v12;  
  } //这里的Source就是ABCDEfghijklmnopqrsTUVWXYZabcdeFGHIJKLMNOPQRStuvwxyz0123456789-_
```

**sub_4116C7(Str, len, v10, 0);**

base64加密

### **网刃杯**

### REVERSE

#### freestyle

1、 4 _ (3 _ atoi(&s) / 9 - 9) == 4400

2、2 * (atoi(&s) % 56) == 98

解方程。再32MD5小写得到flag

```
flag{31a364d51abd0c8304106c16779d83b1}
```

#### Re_function

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main()
{ 
  
int text[40] = {0x64, 0x71, 0x54, 0x54, 0x64, 0x78, 0x74, 0x78, 0x64, 0x41, 
  0x40, 0x48, 0x70, 0x6D, 0x18, 0x4A,0x41, 0x78, 0x66, 0x72,0x41, 0x78, 0x5E, 0x4E,0x5D, 0x52, 0x0E, 0x3D};
for (int i = 0;i < 28; i+=2)
{
   text [i]^=0x37;
}
for (int i=0 ;i<28;i++)
printf("%c",text[i]);
int v6,v5,v7;
v5 = 0;


}
```

先用脚本解出密文。

```python
import base64
import string

str1 = "SqcTSxCxSAwHGm/JvxQrvxiNjR9="



string1 = "FeVYKw6a0lDIOsnZQ5EAf2MvjS1GUiLWPTtH4JqRgu3dbC8hrcNo9/mxzpXBky7+"
string2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"


print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))
```

base64变表，解密即可。

```
 b'flag{we1come_t0_wrb}'
```

#### 道格--re2

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>


int main()
{
 int num[45] = { 0x97, 0x64, 0x48, 0xC6, 0x1C, 0x7A, 0x8E, 0x9F,
 0x46, 0xBD, 0x60, 0xE7, 0x82, 0xF3, 0xEE, 0x69,
 0x49, 0xF7, 0x0E, 0xE3, 0xE2, 0x17, 0xC0, 0xB9,
 0x2C, 0x39, 0x30, 0xA4, 0x48, 0x01, 0x41, 0x98,
 0x39, 0xA9, 0xB5, 0xE5, 0x11, 0x74, 0x0E, 0xE8,
 0xAC, 0xFD, 0x8B, 0xA5, 0x6d
 };

 int x[45] ={
  0x7B, 0x51, 0xF3, 0x5A, 0xCC, 0x39, 0xF9, 0x92, 0x1C, 0x9E, 
  0x58, 0x69, 0x9D, 0xF7, 0xFD, 0x4A, 0x3E, 0xFB, 0x1D, 0x2C, 
  0x4D, 0x0C, 0x70, 0xB1, 0x3B, 0x8D, 0x25, 0xED, 0x91, 0xB1, 
  0x73, 0x8D, 0x82, 0xE6, 0xE7, 0x50, 0x20, 0x61, 0x62, 0x3C, 
  0x00, 0x3A, 0xA6, 0x9D, 0x32
};
char flag[45] ;


for(int  i=0;i<45;i++)
{
	for(int j=33;j<=126;j++)
	{
		int v1 = 23 *j;
		char c = (((v1 + x[i]) >> 31) >> 24) + v1 + x[i] - (((v1 + x[i]) >> 31) >> 24);
		
		if (  c == (char)num[i] )
		{
			printf("%c",j);
		}
	} 
}
 
}
```

#### BASE64超级变表脚本

```python
s = "ABCDEfghijklmnopqrsTUVWXYZabcdeFGHIJKLMNOPQRStuvwxyz0123456789-_"  # 这里是被修改后的表 例："ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234{}789+/"


def My_base64_encode(inputs):
    # 将字符串转化为2进制
    bin_str = []
    for i in inputs:
        x = str(bin(ord(i))).replace('0b', '')  # 这里是输入正常字符串使用 例：'MTIzNDU2'
        # x = str(bin((i))).replace('0b', '') #这里是输入十六进制是使用 例：b'\x9e\x9b\x9c\xb5\xfe\x70\xd3\x0f\xb2\xd1\x4f\x9c\x02\x7f\xab\xde\x59\x65\x63\xe7\x40\x9d\xcd\xfa\x04'
        # 上面两句二选一
        bin_str.append('{:0>8}'.format(x))
    # print(bin_str)
    # 输出的字符串
    outputs = ""
    # 不够三倍数，需补齐的次数
    nums = 0
    while bin_str:
        # 每次取三个字符的二进制
        temp_list = bin_str[:3]
        if (len(temp_list) != 3):
            nums = 3 - len(temp_list)
            while len(temp_list) < 3:
                temp_list += ['0' * 8]
        temp_str = "".join(temp_list)
        # print(temp_str)
        # 将三个8字节的二进制转换为4个十进制
        temp_str_list = []
        for i in range(0, 4):
            temp_str_list.append(int(temp_str[i * 6:(i + 1) * 6], 2))
        # print(temp_str_list)
        if nums:
            temp_str_list = temp_str_list[0:4 - nums]

        for i in temp_str_list:
            outputs += s[i]
        bin_str = bin_str[3:]
    outputs += nums * '='
    print("Encrypted String:\n%s " % outputs)


def My_base64_decode(inputs):
    # 将字符串转化为2进制
    bin_str = []
    for i in inputs:
        if i != '=':
            x = str(bin(s.index(i))).replace('0b', '')
            bin_str.append('{:0>6}'.format(x))
    # print(bin_str)
    # 输出的字符串
    outputs = ""
    nums = inputs.count('=')
    while bin_str:
        temp_list = bin_str[:4]
        temp_str = "".join(temp_list)
        # print(temp_str)
        # 补足8位字节
        if (len(temp_str) % 8 != 0):
            temp_str = temp_str[0:-1 * nums * 2]
        # 将四个6字节的二进制转换为三个字符
        for i in range(0, int(len(temp_str) / 8)):
            outputs += chr(int(temp_str[i * 8:(i + 1) * 8], 2))
        bin_str = bin_str[4:]
    print("Decrypted String:\n%s " % outputs)


print()
print("     -------------------------------------")
print("     |    (1)encode         (2)decode    |")
print("     -------------------------------------")
print()

num = input("Please select the operation you want to perform:\n")
if (num == "1"):
    input_str = input("Please enter a string that needs to be encrypted: \n")  # 这句在终端中输入要加密的数据
    # input_str = b'\x9e\x9b\x9c\xb5\xfe\x70\xd3\x0f\xb2\xd1\x4f\x9c\x02\x7f\xab\xde\x59\x65\x63\xe7\x40\x9d\xcd\xfa\x04'  #这句可以定义要加密的变量
    # 上面两句二选一
    My_base64_encode(input_str)  # 这里传入要加密的数据
else:
    input_str = input("Please enter a string that needs to be decrypted: \n")  # 这句在终端中输入要解密的数据
    # input_str = b'\x9e\x9b\x9c\xb5\xfe\x70\xd3\x0f\xb2\xd1\x4f\x9c\x02\x7f\xab\xde\x59\x65\x63\xe7\x40\x9d\xcd\xfa\x04'  #这句可以定义要解密的变量
    # 上面两句二选一
    My_base64_decode(input_str)  # 这里传入要解密的数据
```

#### 转轮机解密脚本：

```python
import re

table=[3,12,6,8,7,2,4,11,1,5,9,10]#key
Ciphertext='UUEFEZXDDMTO'
with open('C:\\Users\\shuai\\Desktop\\1.txt','r') as f:#轮子
    data=f.read()

#转轮机根据table重新排列
def wheel_decode(data,table):
    resultList=[]
    pattern = re.compile('[A-Z]{26}')
    result = pattern.findall(data)

    for i in table:
        resultList.append(result[i-1])
    return resultList

resultList = wheel_decode(data,table)



#根据密文重新排列
def rearrange(List,Ciphertext):
    resultList=[]
    for i in range(0,12):
        resultList.append(List[i][List[i].find(Ciphertext[i]):]+List[i][:List[i].find(Ciphertext[i])])
    return resultList
resultList= rearrange(resultList,Ciphertext)

#选取每一列，列出结果
def rearrange2(List):
    resultList=[]
    s=''
    for i in range(0,26):
        for j in List:
            s += j[i]

        resultList.append(s)
        s=''
    return resultList

resultList = rearrange2(resultList)
for i in resultList:
    print(i)
```

### Android逆向入门

#### java中native的用法

native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。

JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。

[java中native的用法 - 不止吧 - 博客园 (cnblogs.com)](https://www.cnblogs.com/b3051/p/7484501.html)

**
ezGo**

## **知识点:** Golang 桌面应用逆向、大整数分解、Rabin 算法

## **解题步骤:**

1. 拖入 ida，根据函数列表找到 main_main 函数

![](%E9%80%86%E5%90%91.assets/640#crop=0&crop=0&crop=1&crop=1&id=En67l&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

分析 main_main 函数内容可以得知，判定了输入的长度为 40 且对输入内容的每一位进行编码成一个整数（效果类似于 python 中的 bytes_to_long）

接下来对编码后的信息进行平方然后再对一个大数取模（mod n）

取模后会与一串内容进行比对，如果一致就输出 Correct，否则输出 Incorrect

![](%E9%80%86%E5%90%91.assets/image-20220727175821228.png#crop=0&crop=0&crop=1&crop=1&id=dsPHt&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

根据操作内容可以猜测到程序使用了 Rabin 算法进行加密，解密方法如下

![](%E9%80%86%E5%90%91.assets/641.png#crop=0&crop=0&crop=1&crop=1&id=wbXqz&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

根据解密方法可以得知，如果需要解密需要求得 p q 两个质数，且满足 n = p * q，我们现在有了 n，所以尝试使用 yafu 进行分解，分解可以得到 p 和 q

yafu命令分解

```
yafu-x64 factor(23333333333333)
```

```python
import gmpy2
from Crypto.Util.number import *


def rabin_decrypt(c, p, q):
    n = p * q
    mp = pow(c, (p + 1) // 4, p)
    mq = pow(c, (q + 1) // 4, q)
    yp = gmpy2.invert(p, q)
    yq = gmpy2.invert(q, p)
    r = (yp * p * mq + yq * q * mp) % n
    rr = n - r
    s = (yp * p * mq - yq * q * mp) % n
    ss = n - s
    return r, rr, s, ss
c = 33529281532734294938614341047870321616766628114182320093600990983456360122704185955921012051918080449587733939007294096845300395098833835443815283246602601870001850089370636
p = 7516261744453902635364442762653073356746063224482072262455102025715350278471780391042196223686233375846890331396948280463168691132631674699134296333350979
q = 17489158711316178659
r, rr, s, ss = rabin_decrypt(c, p, q)
print(long_to_bytes(ss))
print(long_to_bytes(s)) #b'DASCTF{48fa8aa2b489e9adac1750ea16ddc7b5}'
print(long_to_bytes(r))
print(long_to_bytes(rr))
```

### 强网杯 RE

#### gameMaster

读取gamemassage文件进行异或和aes解密

```python
from Crypto.Cipher import AES

def add_to_16(text):
    while len(text) % 16 != 0:
        text += b'\0'
    return (text)

def encrypt(plain_text, key):
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.encrypt(plain_text)

def decrypt(cipher_text, key):
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.decrypt(cipher_text)

with open('D:\\CTF-Comp\\强网杯\\GameMaster\\gamemessage', 'rb') as fp:
    data = fp.read()
    data = add_to_16(data)
    data = bytearray(data)


for i in range(len(data)):
    data[i] ^= 34
d0 = decrypt(bytearray(data), b'\x42\x72\x61\x69\x6e\x73\x74\x6f\x72\x6d\x69\x6e\x67\x21\x21\x21')
with open('D:\\CTF-Comp\\强网杯\\GameMaster\\out.txt', 'wb') as fp:
    fp.write(d0)
```

这里需要注意一点，aes解密密文长度必须位16的倍数，**add_to_16(text)**这个函数就是用来补充长度的。

解出来的文件放进010中又发现个exe文件还是c#写的。

这里先生成三个整数。

![](%E9%80%86%E5%90%91.assets/image-20220806111640489.png#crop=0&crop=0&crop=1&crop=1&id=Dsckb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```c
private static void Check1(ulong x, ulong y, ulong z, byte[] KeyStream)
{
	int num = -1;
	for (int i = 0; i < 320; i++)
	{
		x = (((x >> 29 ^ x >> 28 ^ x >> 25 ^ x >> 23) & 1uL) | x << 1);
		y = (((y >> 30 ^ y >> 27) & 1uL) | y << 1);
		z = (((z >> 31 ^ z >> 30 ^ z >> 29 ^ z >> 28 ^ z >> 26 ^ z >> 24) & 1uL) | z << 1);
		bool flag = i % 8 == 0;
		if (flag)
		{
			num++;
		}
		KeyStream[num] = (byte)((long)((long)KeyStream[num] << 1) | (long)((ulong)((uint)((z >> 32 & 1uL & (x >> 30 & 1uL)) ^ (((z >> 32 & 1uL) ^ 1uL) & (y >> 31 & 1uL))))));
	}
}
```

check1函数传入这个三个数返回一个数组，这个数组的值与first数组的值进行比较。

用z3解出这三个数。

```python
from z3 import *

x = BitVec('x', 64)
y = BitVec('y', 64)
z = BitVec('z', 64)

num = -1
keystream = [0 for i in range(40)]

for i in range(320):
    x = (((x >> 29) ^ (x >> 28) ^ (x >> 25) ^ (x >> 23)) & 1) | (x << 1)
    y = (((y >> 30) ^ (y >> 27)) & 1) | (y << 1)
    z = (((z >> 31) ^ (z >> 30) ^ (z >> 29) ^ (z >> 28) ^ (z >> 26) ^ (z >> 24)) & 1) | (z << 1)
    if i % 8 == 0:
        num += 1
    keystream[num] = ((keystream[num] << 1) | (((z >> 32) & 1 & ((x >> 30) & 1)) ^ ((((z >> 32) & 1) ^ 1) & ((y >> 31) & 1)))) & 0xff

solver = Solver()
solver.add(keystream[0] == 101)
solver.add(keystream[1] == 5)
solver.add(keystream[2] == 80)
solver.add(keystream[3] == 213)
solver.add(keystream[4] == 163)
solver.add(keystream[5] == 26)
solver.add(keystream[6] == 59)
solver.add(keystream[7] == 38)
solver.add(keystream[8] == 19)
solver.add(keystream[9] == 6)
solver.add(keystream[10] == 173)
solver.add(keystream[11] == 189)
solver.add(keystream[12] == 198)
solver.add(keystream[13] == 166)
solver.add(keystream[14] == 140)
solver.add(keystream[15] == 183)
solver.add(keystream[16] == 42)
solver.add(keystream[17] == 247)
solver.add(keystream[18] == 223)
solver.add(keystream[19] == 24)
solver.add(keystream[20] == 106)
solver.add(keystream[21] == 20)
solver.add(keystream[22] == 145)
solver.add(keystream[23] == 37)
solver.add(keystream[24] == 24)
solver.add(keystream[25] == 7)
solver.add(keystream[26] == 22)
solver.add(keystream[27] == 191)
solver.add(keystream[28] == 110)
solver.add(keystream[29] == 179)
solver.add(keystream[30] == 227)
solver.add(keystream[31] == 5)
solver.add(keystream[32] == 62)
solver.add(keystream[33] == 9)
solver.add(keystream[34] == 13)
solver.add(keystream[35] == 17)
solver.add(keystream[36] == 65)
solver.add(keystream[37] == 22)
solver.add(keystream[38] == 37)
solver.add(keystream[39] == 5)

if solver.check() == sat:
    print(solver.model())
```

（比赛时没看出来用z3怎么解）呜呜

#### deeprev

先来个linux命令小知识：

我在使用readelf  -r  deeprev 这个命令时只显示最后一页前面的数据看不着。

> 一、在执行命令的时候在后面加个”|more”，就如同我使用”dpkg –l|more”，然后按回车键,一行一行显示,按空格键，一页一页显示。不过这个方法有个弊端，就是只能一直向下翻页，无法向上查看内容。
>  
> 二、同方法1，只是在执行命令的时候，在后面加上”|less”，这个要比more好用的多，它可以用”PageUp”和”PageDown”按键上下翻页，也可以用上下方向键一点点查看。退出按q。
>  
> 三、可以将输出重定向。例如可以执行命令”dpkg–l >a.c”，这样你就会发现在当前目录多了一个a.c文件，然后查看该文件，就是你所想要显示的内容。所谓的重定向也很好理解：就是将本来应该在终端上显示的内容显示在了文件里面。


##### 64位重定位

[ELF重定位 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAxNjIyNDgzNw==&mid=2247488904&idx=1&sn=78cb9a50f76b471d760e37be0527a026&chksm=9bf952a2ac8edbb499f71102b3d506f23a1be5e5859913f292bf28c4a24d369564d96149256e&token=1265574353&lang=zh_CN#rd)

[https://docs.oracle.com/cd/E19253-01/819-7050/chapter7-2/index.html](https://docs.oracle.com/cd/E19253-01/819-7050/chapter7-2/index.html)

```
A：用于计算可重定位字段值的加数。

B：共享对象在执行过程中加载到内存的基地址。

一般情况下，共享对象文件是用0的虚拟基地址构建的，但是共享对象的执行地址是不同的。

见程序头。

G：执行时重定位项的符号地址所在的全局偏移表中的偏移量。

GOT：全局偏移表的地址。

L：符号的过程链接表项的段偏移量或地址。

P：被重定位的存储单元的段偏移或地址，使用r_offset计算。

S：索引位于重定位项中的符号的值。

Z：索引位于重定位项的符号的大小。
```

80 40 cc 25 04 80

[2022强网杯初赛-逆向 (notion.site)](https://agate-colony-3f5.notion.site/2022-bd85163978a94cdfb2d05e5492bde41c#8e90ad5988c94336bc36a13233ee3eba)

[2022--第六届“强网杯”全国网络安全挑战赛---WriteUp - Bit's Blog (xl-bit.cn)](https://www.xl-bit.cn/index.php/archives/839/)

[强网杯2022 By W&M - W&M Team (wm-team.cn)](https://blog.wm-team.cn/index.php/archives/23/)

# MCH2022CTF - MySimpleLogin

-  [mch2022ctf](https://ab2pentest.github.io/tags.html?tag=mch2022ctf) 
-  [安卓](https://ab2pentest.github.io/tags.html?tag=android) 
-  [APK](https://ab2pentest.github.io/tags.html?tag=apk) 
-  [撤销](https://ab2pentest.github.io/tags.html?tag=reverse) 
-  2022 年 7 月 26 日 

# 描述

![](181047281-3ca8b815-7642-4497-8f9c-353f16a00dae.png)

# 解决方案

我们得到了一个 APK 文件

[MySimpleLogin.zip](https://github.com/ab2pentest/ab2pentest.github.io/files/9191147/MySimpleLogin.zip)

![](181047436-7a829280-379b-4711-bc60-42742f8e25fe.png)

下载后，让我们在任何地方打开它`Android dex decompiler`……

首先是寻找入口点或主要活动，这可以在`AndroidManifest.xml`文件中找到

![](181079155-a0d568ea-ddb7-455e-9972-a4a892de12a3.png)

我们的 MainActivity`ctf.challenges.mysimplelogin.MainActivity`如上面的截图所示，所以让我们去那里检查一下我们有什么

![](181080067-90b3be68-23e9-4421-8cad-a172836803dd.png)

所以从反编译的代码很明显我们有一个密码检查器，这个函数解释了它

![](181080733-72c304ee-1557-4dc8-ac21-c31003617f00.png)

因此，函数 get 是我们定义的输入值`i`并将其添加到字符串值`s`并将其传递给调用的函数并检查它的`l`输出是否等于调用它看起来有点不合逻辑，让我们现在忽略它并继续阅读代码......`h``showError(w);``showFlag(f);`

[+]`l`功能：

这个函数只是计算md5sum`i+s`

![](181081555-50cb2c2a-7a4d-4650-a921-02cb378078a3.png)

伟大的 ！但是在哪里`s`以及`h`所有定义的字符串值......，在反编译的代码中我们可以看到它们来自资源

```
        String s = getResources().getString(R.string.OO0O00OOO00O0O);
        String h = getResources().getString(R.string.OO0O00OOO00OOO);
        String f = getResources().getString(R.string.OO0O0O0OO00OOO);
        String w = getResources().getString(R.string.OO0O0OOOO00OOO);
```

所以在路径中`res/values/strings.xml`这些值被保存

![](181082923-6e104e26-22a1-4d41-aa3c-e95ba1692f7b.png)

[+]`s`价值：

![](181081326-15c62b1b-50a5-4cfe-b583-4fe216f755d8.png)

[+]`h`价值：

![](181083212-07d3231f-180c-44d8-b8cc-70443e77adfe.png)

[+]`f`价值：

被召入`showFlag(f);`

![](181083990-b3bbd6f5-9d22-4de6-a56e-4ea16e7540a2.png)

[+]`w`价值：

被召唤进来`showError(w);`

![](181084106-d3129dc2-5996-4883-9a8d-fc33c8a8f3e4.png)

现在我确认这`showError(w);`是我们的标志被保存的地方而不是在`showFlag(f);`，所以让我们检查一下

![](181085016-83d5e086-9a31-42e8-aeb2-0b3238073dba.png)

因此，如果我们给它正确的输入，它会将它传递给`x`函数一次和 7 次`r`，所以我没有浪费很多时间，我立即将这 3 个函数复制到一个新的 .java 文件中

**注意： 的原始值**`**w**`**有一些转义字符，所以我将它粘贴到这个**[**HTML 实体解码器**](https://www.online-toolz.com/tools/text-html-entities-convertor.php)

```
public class MainActivity{
	
    public static void showError(String e) {
        System.out.println(x(r(r(r(r(r(r(r(e, "r"), "s"), "t"), "u"), "v"), "w"), "x"), "X"));
    }

	public static String r(String s, String c) {
		return s.replace(c, "");
	}

	public static String x(String s, String k) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			sb.append((char) (s.charAt(i) ^ k.charAt(i % k.length())));
		}
		return sb.toString();
	}
	
	public static void main(String[] args) {
		showError(">49s?#kjllw>ijvnra;;i>=kuki`ta;`iirj9::xtm;<rij%");
    }
}
```

# 旗帜

只需运行上面的脚本，它就会为您打印出标志

![](181085672-5b57ce5a-065f-4ae8-b9d9-679d1bd86521.png)
